import { useState, useEffect, useRef, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { 
  MessageCircle, 
  X, 
  Send, 
  Minimize2, 
  Maximize2,
  Bot,
  User,
  ShoppingCart,
  Package,
  Clock,
  CheckCircle,
  AlertCircle
} from "lucide-react";

interface Message {
  id: string;
  text: string;
  isBot: boolean;
  timestamp: Date;
  suggestions?: string[];
  productData?: {
    id: string;
    name: string;
    price: string;
    image: string;
    stock?: number;
  };
  orderData?: {
    total: number;
    items: Array<{
      name: string;
      quantity: number;
      price: number;
    }>;
  };
}

interface ChatbotWidgetProps {
  pageType: "storefront" | "landing_page";
  pageContext?: {
    storefrontName?: string;
    products?: Array<{
      id: string;
      name: string;
      price: string;
      category: string;
    }>;
    featuredProduct?: {
      id: string;
      name: string;
      price: string;
      description: string;
    };
    cartItems?: Array<{
      productId: string;
      name: string;
      quantity: number;
    }>;
  };
  onAddToCart?: (productId: string, quantity: number) => void;
  onCreateOrder?: (orderData: any) => void;
}

export default function ChatbotWidget({
  pageType,
  pageContext,
  onAddToCart,
  onCreateOrder
}: ChatbotWidgetProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [newMessageIds, setNewMessageIds] = useState<Set<string>>(new Set());
  const [connectionStatus, setConnectionStatus] = useState<'connected' | 'connecting' | 'error'>('connected');
  const [retryCount, setRetryCount] = useState(0);
  const [isNetworkError, setIsNetworkError] = useState(false);
  const [lastSeenMessageId, setLastSeenMessageId] = useState<string | null>(null);
  const [conversationId] = useState(() => `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const lastUserMessageRef = useRef<Date>(new Date());
  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Smart positioning calculations
  const getSmartPositioning = useCallback(() => {
    const isLandingPage = pageType === "landing_page";
    const isMobile = window.innerWidth < 768;
    
    // Landing pages have sticky bottom CTAs that need 80px clearance on mobile
    const mobileBottomOffset = isLandingPage && isMobile ? "6rem" : "1rem"; // 96px vs 16px
    const desktopBottomOffset = "5rem"; // 80px for desktop popup
    
    // Ensure chatbot is above landing page sticky bars (z-50 + 1)
    const zIndexValue = 9999;
    
    return {
      mobileBottomOffset,
      desktopBottomOffset,
      zIndexValue
    };
  }, [pageType]);

  const positioning = getSmartPositioning();

  // Enhanced visibility entrance animation
  useEffect(() => {
    const timer = setTimeout(() => setIsVisible(true), 500);
    return () => clearTimeout(timer);
  }, []);

  // Enhanced welcome message with comprehensive context awareness
  const getWelcomeMessage = useCallback((): Message => {
    const featuredProduct = pageContext?.featuredProduct;
    const storefrontName = pageContext?.storefrontName;
    const cartItemCount = pageContext?.cartItems?.length || 0;
    const hasProducts = pageContext?.products && pageContext.products.length > 0;
    
    let text: string;
    let suggestions: string[];
    
    if (pageType === "storefront") {
      if (cartItemCount > 0) {
        text = `Ch√†o m·ª´ng b·∫°n tr·ªü l·∫°i! üõí B·∫°n c√≥ ${cartItemCount} s·∫£n ph·∫©m trong gi·ªè h√†ng. T√¥i c√≥ th·ªÉ gi√∫p g√¨ th√™m cho b·∫°n?`;
        suggestions = ["Xem gi·ªè h√†ng", "Thanh to√°n lu√¥n", "Th√™m s·∫£n ph·∫©m", "T∆∞ v·∫•n ∆∞u ƒë√£i"];
      } else {
        text = storefrontName 
          ? `Ch√†o b·∫°n! üëã T√¥i l√† tr·ª£ l√Ω AI c·ªßa ${storefrontName}. S·∫µn s√†ng gi√∫p b·∫°n t√¨m ki·∫øm v√† mua s·∫Øm d·ªÖ d√†ng!`
          : `Ch√†o b·∫°n! üëã T√¥i l√† tr·ª£ l√Ω mua s·∫Øm AI. H√£y ƒë·ªÉ t√¥i gi√∫p b·∫°n t√¨m ƒë∆∞·ª£c s·∫£n ph·∫©m ∆∞ng √Ω!`;
        suggestions = hasProducts 
          ? ["S·∫£n ph·∫©m hot", "T√¨m theo gi√°", "Danh m·ª•c", "∆Øu ƒë√£i hi·ªán t·∫°i"]
          : ["T√¨m s·∫£n ph·∫©m", "Ki·ªÉm tra t·ªìn kho", "T∆∞ v·∫•n mua h√†ng", "Li√™n h·ªá h·ªó tr·ª£"];
      }
    } else {
      // Landing page context
      if (featuredProduct) {
        const productName = featuredProduct.name;
        const hasPrice = featuredProduct.price && featuredProduct.price !== '0';
        
        text = `Ch√†o b·∫°n! üåü T√¥i th·∫•y b·∫°n quan t√¢m ƒë·∫øn ${productName}. ${hasPrice ? `Gi√° ch·ªâ ${parseInt(featuredProduct.price).toLocaleString('vi-VN')}ƒë.` : ''} B·∫°n mu·ªën t√¨m hi·ªÉu ƒëi·ªÅu g√¨?`;
        
        suggestions = [
          `∆Øu ƒëi·ªÉm ${productName}`,
          "C√°ch s·ª≠ d·ª•ng", 
          "ƒê·∫∑t h√†ng ngay",
          "So s√°nh s·∫£n ph·∫©m"
        ];
      } else {
        text = `Ch√†o b·∫°n! üéØ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m hi·ªÉu chi ti·∫øt v·ªÅ s·∫£n ph·∫©m n√†y v√† h·ªó tr·ª£ ƒë·∫∑t h√†ng. B·∫°n quan t√¢m ƒëi·ªÅu g√¨ nh·∫•t?`;
        suggestions = ["Th√¥ng s·ªë s·∫£n ph·∫©m", "Gi√° c·∫£ ∆∞u ƒë√£i", "C√°ch ƒë·∫∑t h√†ng", "Ch√≠nh s√°ch b·∫£o h√†nh"];
      }
    }
    
    return {
      id: `msg_${Date.now()}`,
      text,
      isBot: true,
      timestamp: new Date(),
      suggestions
    };
  }, [pageType, pageContext]);

  // Welcome message initialization
  useEffect(() => {
    if (isOpen && messages.length === 0) {
      const welcomeMessage = getWelcomeMessage();
      setMessages([welcomeMessage]);
    }
  }, [isOpen, messages.length, getWelcomeMessage]);

  // Enhanced unread message tracking with better counting
  useEffect(() => {
    if (!isOpen) {
      // Count unread messages since last seen
      const unreadMessages = lastSeenMessageId 
        ? messages.filter(m => {
            const messageIndex = messages.findIndex(msg => msg.id === lastSeenMessageId);
            const currentIndex = messages.findIndex(msg => msg.id === m.id);
            return m.isBot && currentIndex > messageIndex && !m.text.includes("Ch√†o b·∫°n");
          })
        : messages.filter(m => m.isBot && !m.text.includes("Ch√†o b·∫°n"));
      
      setUnreadCount(unreadMessages.length);
    } else {
      // Mark all messages as seen when chat is opened
      const lastMessage = messages[messages.length - 1];
      if (lastMessage) {
        setLastSeenMessageId(lastMessage.id);
      }
      setUnreadCount(0);
      setNewMessageIds(new Set());
    }
  }, [isOpen, messages, lastSeenMessageId]);

  // Enhanced typing indicator with realistic timing
  useEffect(() => {
    let typingTimeout: NodeJS.Timeout;
    
    if (isTyping) {
      // Simulate more realistic typing duration based on message length
      const estimatedTypingTime = Math.min(Math.max(1000, inputValue.length * 50), 3000);
      typingTimeout = setTimeout(() => {
        setIsTyping(false);
      }, estimatedTypingTime);
    }
    
    return () => {
      if (typingTimeout) clearTimeout(typingTimeout);
    };
  }, [isTyping, inputValue.length]);

  // Cleanup retry timeout on unmount
  useEffect(() => {
    return () => {
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, []);

  // Auto scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "instant" });
  }, [messages.length]);

  // Enhanced auto-focus with better timing and accessibility
  useEffect(() => {
    if (isOpen && !isMinimized) {
      // Improved auto-focus timing for better UX
      const focusTimer = setTimeout(() => {
        // Only focus if not on mobile to avoid virtual keyboard issues
        const isMobile = window.innerWidth < 768;
        if (!isMobile && inputRef.current) {
          inputRef.current.focus();
          // Set cursor to end for better UX
          inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
        }
      }, 200); // Slightly longer delay for smoother experience
      
      return () => clearTimeout(focusTimer);
    }
  }, [isOpen, isMinimized]);

  const sendMessage = async (text: string) => {
    if (!text.trim()) return;

    lastUserMessageRef.current = new Date();

    // Add user message
    const userMessage: Message = {
      id: `msg_${Date.now()}`,
      text: text.trim(),
      isBot: false,
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue("");
    setIsTyping(true);

    try {
      // Send to RASA API with context
      const response = await fetch('/api/rasa/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: text.trim(),
          sender: conversationId,
          context: {
            page_type: pageType,
            ...pageContext
          }
        })
      });

      const data = await response.json();
      
      // Enhanced RASA response processing with context awareness
      if (data.responses && data.responses.length > 0) {
        for (const rasaResponse of data.responses) {
          const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Enhanced fallback messages with context
          let fallbackText = "Xin l·ªói, t√¥i kh√¥ng hi·ªÉu r√µ. ";
          if (pageType === "landing_page" && pageContext?.featuredProduct) {
            fallbackText += `B·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ ${pageContext.featuredProduct.name}, gi√° c·∫£, ho·∫∑c c√°ch ƒë·∫∑t h√†ng?`;
          } else if (pageType === "storefront") {
            fallbackText += "B·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ s·∫£n ph·∫©m, gi√° c·∫£, t·ªìn kho, ho·∫∑c c√°ch ƒë·∫∑t h√†ng?";
          } else {
            fallbackText += "B·∫°n c√≥ th·ªÉ h·ªèi l·∫°i r√µ h∆°n kh√¥ng?";
          }
          
          // Enhanced suggestions based on context
          let contextSuggestions = rasaResponse.buttons?.map((btn: any) => btn.title);
          if (!contextSuggestions || contextSuggestions.length === 0) {
            const cartItems = pageContext?.cartItems?.length || 0;
            if (pageType === "landing_page") {
              contextSuggestions = ["Chi ti·∫øt s·∫£n ph·∫©m", "Gi√° b√°n", "ƒê·∫∑t h√†ng", "H·ªó tr·ª£"];
            } else if (cartItems > 0) {
              contextSuggestions = ["Xem gi·ªè h√†ng", "S·∫£n ph·∫©m m·ªõi", "Thanh to√°n", "T∆∞ v·∫•n"];
            } else {
              contextSuggestions = ["T√¨m s·∫£n ph·∫©m", "Danh m·ª•c", "∆Øu ƒë√£i", "H·ªó tr·ª£"];
            }
          }
          
          const botMessage: Message = {
            id: messageId,
            text: rasaResponse.text || fallbackText,
            isBot: true,
            timestamp: new Date(),
            suggestions: contextSuggestions,
            productData: rasaResponse.custom?.product,
            orderData: rasaResponse.custom?.order
          };
          
          // Mark as new message for animation
          setNewMessageIds(prev => {
            const newSet = new Set(prev);
            newSet.add(messageId);
            return newSet;
          });
          
          setMessages(prev => [...prev, botMessage]);
          
          // Remove from new messages after animation
          setTimeout(() => {
            setNewMessageIds(prev => {
              const newSet = new Set(prev);
              newSet.delete(messageId);
              return newSet;
            });
          }, 500);
          
          // Small delay between multiple responses
          if (data.responses.length > 1) {
            await new Promise(resolve => setTimeout(resolve, 800));
          }
        }
      } else {
        // Fallback response
        const fallbackMessage: Message = {
          id: `msg_${Date.now()}`,
          text: "Xin l·ªói, t√¥i ƒëang g·∫∑p s·ª± c·ªë. B·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i kh√¥ng?",
          isBot: true,
          timestamp: new Date()
        };
        setMessages(prev => [...prev, fallbackMessage]);
      }
    } catch (error) {
      console.error('Chat error:', error);
      setConnectionStatus('error');
      setRetryCount(prev => prev + 1);
      setIsNetworkError(true);
      
      // Enhanced error messages based on error type
      let errorText = "C√≥ l·ªói x·∫£y ra. ";
      let suggestions: string[] = [];
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        errorText = "üîå M·∫•t k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet v√† th·ª≠ l·∫°i.";
        suggestions = ["Th·ª≠ l·∫°i", "Ki·ªÉm tra m·∫°ng", "Li√™n h·ªá h·ªó tr·ª£"];
      } else if (retryCount >= 3) {
        errorText = "‚ùå H·ªá th·ªëng t·∫°m th·ªùi g·∫∑p s·ª± c·ªë. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t.";
        suggestions = ["Th·ª≠ l·∫°i sau", "Li√™n h·ªá tr·ª±c ti·∫øp", "Xem FAQ"];
      } else {
        errorText = "‚ö†Ô∏è C√≥ l·ªói nh·ªè x·∫£y ra. T√¥i s·∫Ω th·ª≠ k·∫øt n·ªëi l·∫°i...";
        suggestions = ["Th·ª≠ l·∫°i ngay", "G·ª≠i l·∫°i tin nh·∫Øn"];
        
        // Auto retry after 2 seconds
        retryTimeoutRef.current = setTimeout(() => {
          sendMessage(text);
        }, 2000);
      }
      
      const errorMessage: Message = {
        id: `msg_${Date.now()}`,
        text: errorText,
        isBot: true,
        timestamp: new Date(),
        suggestions
      };
      setMessages(prev => [...prev, errorMessage]);
      
      // Reset connection status after 5 seconds
      setTimeout(() => {
        setConnectionStatus('connected');
        setIsNetworkError(false);
      }, 5000);
    } finally {
      setIsTyping(false);
    }
  };

  const handleSuggestionClick = (suggestion: string) => {
    sendMessage(suggestion);
  };

  const handleProductAction = (action: string, productData: any) => {
    if (action === "add_to_cart" && onAddToCart) {
      onAddToCart(productData.id, 1);
      
      // Enhanced confirmation message with cart context
      const cartItemCount = (pageContext?.cartItems?.length || 0) + 1;
      const confirmMessage: Message = {
        id: `msg_${Date.now()}`,
        text: `‚úÖ ƒê√£ th√™m ${productData.name} v√†o gi·ªè h√†ng! B·∫°n hi·ªán c√≥ ${cartItemCount} s·∫£n ph·∫©m trong gi·ªè.`,
        isBot: true,
        timestamp: new Date(),
        suggestions: cartItemCount >= 2 
          ? ["Xem gi·ªè h√†ng", "Ti·∫øp t·ª•c mua s·∫Øm", "Thanh to√°n ngay", "C·∫ßn t∆∞ v·∫•n th√™m?"]
          : ["Th√™m s·∫£n ph·∫©m kh√°c", "Xem s·∫£n ph·∫©m t∆∞∆°ng t·ª±", "T∆∞ v·∫•n s·ªë l∆∞·ª£ng", "H·ªó tr·ª£ thanh to√°n"]
      };
      setMessages(prev => [...prev, confirmMessage]);
      
      // Trigger new message animation
      setNewMessageIds(prev => {
        const newSet = new Set(prev);
        newSet.add(confirmMessage.id);
        return newSet;
      });
      setTimeout(() => {
        setNewMessageIds(prev => {
          const newSet = new Set(prev);
          newSet.delete(confirmMessage.id);
          return newSet;
        });
      }, 500);
    }
  };

  const renderMessage = (message: Message) => {
    const isNewMessage = newMessageIds.has(message.id);
    
    return (
      <div
        key={message.id}
        className={`flex ${message.isBot ? "justify-start" : "justify-end"} mb-4`}
      >
        <div className={`flex items-start space-x-2 max-w-[85%] ${message.isBot ? "" : "flex-row-reverse space-x-reverse"}`}>
          {/* Enhanced Avatar with status indicator */}
          <div className={`w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0 relative transition-all duration-200 ${
            message.isBot ? "bg-gradient-to-br from-green-500 to-green-600 shadow-lg" : "bg-gradient-to-br from-blue-500 to-blue-600 shadow-lg"
          }`}>
            {message.isBot ? (
              <Bot className="w-4 h-4 text-white" />
            ) : (
              <User className="w-4 h-4 text-white" />
            )}
            {/* Online indicator for bot */}
            {message.isBot && (
              <div className="absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-400 rounded-full border-2 border-white shadow-sm animate-pulse" />
            )}
          </div>

          {/* Enhanced Message Content */}
          <div className={`rounded-xl px-4 py-2 shadow-sm transition-all duration-200 hover:shadow-md ${
            message.isBot 
              ? "bg-white border border-gray-100 text-gray-800" 
              : "bg-gradient-to-r from-blue-500 to-blue-600 text-white"
          }`}>
          <p className="text-sm">{message.text}</p>
          
          {/* Product Card */}
          {message.productData && (
            <div className="mt-2 p-3 bg-white border rounded-lg shadow-sm">
              <div className="flex items-center space-x-3">
                {message.productData.image && (
                  <img 
                    src={message.productData.image} 
                    alt={message.productData.name}
                    className="w-12 h-12 object-cover rounded"
                  />
                )}
                <div className="flex-1">
                  <h4 className="font-medium text-gray-800">{message.productData.name}</h4>
                  <p className="text-green-600 font-bold">{parseInt(message.productData.price).toLocaleString('vi-VN')}ƒë</p>
                  {message.productData.stock !== undefined && (
                    <p className="text-sm text-gray-500">C√≤n {message.productData.stock} s·∫£n ph·∫©m</p>
                  )}
                </div>
              </div>
              {onAddToCart && (
                <Button
                  size="sm"
                  className="w-full mt-2 bg-green-600 hover:bg-green-700"
                  onClick={() => handleProductAction("add_to_cart", message.productData)}
                >
                  <ShoppingCart className="w-4 h-4 mr-2" />
                  Th√™m v√†o gi·ªè h√†ng
                </Button>
              )}
            </div>
          )}

          {/* Order Summary */}
          {message.orderData && (
            <div className="mt-2 p-3 bg-white border rounded-lg shadow-sm">
              <h4 className="font-medium text-gray-800 mb-2">
                <Package className="w-4 h-4 inline mr-1" />
                T√≥m t·∫Øt ƒë∆°n h√†ng
              </h4>
              {message.orderData.items.map((item, index) => (
                <div key={index} className="flex justify-between text-sm text-gray-600">
                  <span>{item.name} x {item.quantity}</span>
                  <span>{item.price.toLocaleString('vi-VN')}ƒë</span>
                </div>
              ))}
              <div className="border-t mt-2 pt-2 flex justify-between font-bold text-gray-800">
                <span>T·ªïng c·ªông:</span>
                <span>{message.orderData.total.toLocaleString('vi-VN')}ƒë</span>
              </div>
            </div>
          )}

          {/* Suggestions */}
          {message.suggestions && message.suggestions.length > 0 && (
            <div className="mt-2 flex flex-wrap gap-1">
              {message.suggestions.map((suggestion, index) => (
                <Button
                  key={index}
                  size="sm"
                  variant="outline"
                  className="text-xs bg-white border-gray-200 text-gray-700 hover:bg-gray-50"
                  onClick={() => handleSuggestionClick(suggestion)}
                >
                  {suggestion}
                </Button>
              ))}
            </div>
          )}

          {/* Enhanced Timestamp */}
          <p className="text-xs opacity-70 mt-2 flex items-center gap-1">
            <Clock className="w-3 h-3" />
            <span>{message.timestamp.toLocaleTimeString('vi-VN', { 
              hour: '2-digit', 
              minute: '2-digit' 
            })}</span>
            {message.isBot && (
              <CheckCircle className="w-3 h-3 text-green-500 ml-1" />
            )}
          </p>
        </div>
      </div>
    </div>
    );
  };

  // Enhanced Mobile full-screen overlay with smart positioning
  const MobileChat = () => {
    const isLandingPage = pageType === "landing_page";
    
    return (
      <div 
        className="fixed inset-0 bg-white flex flex-col"
        style={{ zIndex: positioning.zIndexValue }}
      >
      {/* Enhanced Header with gradient */}
      <div className="flex items-center justify-between p-4 border-b bg-gradient-to-r from-green-500 to-green-600 text-white shadow-lg">
        <div className="flex items-center gap-2">
          <div className="w-8 h-8 bg-white/20 rounded-full flex items-center justify-center">
            <Bot className="w-4 h-4 text-white" />
          </div>
          <div>
            <h3 className="font-semibold">Tr·ª£ l√Ω mua s·∫Øm</h3>
            <p className="text-xs text-green-100">Tr·ª±c tuy·∫øn</p>
          </div>
        </div>
        <Button
          size="sm"
          variant="ghost"
          onClick={() => setIsOpen(false)}
          className="text-white hover:bg-white/20 transition-colors duration-200"
        >
          <X className="w-5 h-5" />
        </Button>
      </div>

      {/* Enhanced Messages with better spacing */}
      <ScrollArea className="flex-1 p-4 bg-gray-50/30">
        {messages.map(renderMessage)}
        {isTyping && (
          <div className="flex items-center space-x-3 text-gray-500 mb-4">
            <div className="w-8 h-8 bg-gradient-to-br from-green-500 to-green-600 rounded-full flex items-center justify-center">
              <Bot className="w-4 h-4 text-white" />
            </div>
            <div className="bg-white rounded-xl px-4 py-3 shadow-sm border border-gray-100">
              <div className="flex items-center space-x-1">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-bounce"></div>
                <div className="w-2 h-2 bg-green-500 rounded-full animate-bounce" style={{ animationDelay: "0.1s" }}></div>
                <div className="w-2 h-2 bg-green-500 rounded-full animate-bounce" style={{ animationDelay: "0.2s" }}></div>
                <span className="text-xs text-gray-500 ml-2">ƒêang so·∫°n...</span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </ScrollArea>

      {/* Enhanced Input with better visual hierarchy */}
      <div className="p-4 border-t bg-white shadow-lg">
        <div className="flex space-x-3">
          <Input
            ref={inputRef}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={(e) => e.key === "Enter" && !e.shiftKey && sendMessage(inputValue)}
            placeholder="Nh·∫≠p tin nh·∫Øn..."
            className="flex-1 border-gray-200 focus:border-green-500 focus:ring-green-500/20 rounded-xl"
            disabled={isTyping}
          />
          <Button 
            onClick={() => sendMessage(inputValue)}
            disabled={!inputValue.trim() || isTyping}
            className="bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 shadow-lg hover:shadow-xl transition-all duration-200 rounded-xl px-4"
          >
            {isTyping ? (
              <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
            ) : (
              <Send className="w-4 h-4" />
            )}
          </Button>
        </div>
      </div>
    </div>
  );
  };

  // Enhanced Desktop popup with smart positioning
  const DesktopChat = () => (
    <Card 
      className="fixed right-4 w-96 h-96 shadow-2xl flex flex-col animate-in slide-in-from-bottom-4 duration-300 border-0 overflow-hidden"
      style={{
        bottom: positioning.desktopBottomOffset,
        zIndex: positioning.zIndexValue
      }}
    >
      {/* Enhanced Header with status indicator */}
      <CardHeader className="pb-3 bg-gradient-to-r from-green-500 to-green-600 text-white">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="w-6 h-6 bg-white/20 rounded-full flex items-center justify-center">
              <Bot className="w-3 h-3 text-white" />
            </div>
            <div>
              <CardTitle className="text-sm font-medium">Tr·ª£ l√Ω mua s·∫Øm</CardTitle>
              <p className="text-xs text-green-100">Tr·ª±c tuy·∫øn ‚Ä¢ Ph·∫£n h·ªìi nhanh</p>
            </div>
          </div>
          <div className="flex space-x-1">
            <Button
              size="sm"
              variant="ghost"
              onClick={() => setIsMinimized(!isMinimized)}
              className="text-white hover:bg-white/20 p-1 h-6 w-6 transition-colors duration-200"
            >
              {isMinimized ? <Maximize2 className="w-3 h-3" /> : <Minimize2 className="w-3 h-3" />}
            </Button>
            <Button
              size="sm"
              variant="ghost"
              onClick={() => setIsOpen(false)}
              className="text-white hover:bg-white/20 p-1 h-6 w-6 transition-colors duration-200"
            >
              <X className="w-3 h-3" />
            </Button>
          </div>
        </div>
      </CardHeader>

      {!isMinimized && (
        <>
          {/* Enhanced Messages for desktop */}
          <CardContent className="flex-1 p-4 overflow-hidden bg-gray-50/30">
            <ScrollArea className="h-full">
              {messages.map(renderMessage)}
              {isTyping && (
                <div className="flex items-center space-x-3 text-gray-500 mb-4">
                  <div className="w-6 h-6 bg-gradient-to-br from-green-500 to-green-600 rounded-full flex items-center justify-center flex-shrink-0">
                    <Bot className="w-3 h-3 text-white" />
                  </div>
                  <div className="bg-white rounded-lg px-3 py-2 shadow-sm border border-gray-100">
                    <div className="flex items-center space-x-1">
                      <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-bounce"></div>
                      <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-bounce" style={{ animationDelay: "0.1s" }}></div>
                      <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-bounce" style={{ animationDelay: "0.2s" }}></div>
                      <span className="text-xs text-gray-500 ml-2">ƒêang so·∫°n...</span>
                    </div>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </ScrollArea>
          </CardContent>

          {/* Enhanced Input for desktop */}
          <div className="p-4 border-t bg-white">
            <div className="flex space-x-2">
              <Input
                ref={inputRef}
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={(e) => e.key === "Enter" && !e.shiftKey && sendMessage(inputValue)}
                placeholder="Nh·∫≠p tin nh·∫Øn..."
                className="flex-1 text-sm border-gray-200 focus:border-green-500 focus:ring-green-500/20 rounded-lg"
                disabled={isTyping}
              />
              <Button 
                size="sm"
                onClick={() => sendMessage(inputValue)}
                disabled={!inputValue.trim() || isTyping}
                className="bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 shadow-md hover:shadow-lg transition-all duration-200 rounded-lg"
              >
                {isTyping ? (
                  <div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin" />
                ) : (
                  <Send className="w-3 h-3" />
                )}
              </Button>
            </div>
          </div>
        </>
      )}
    </Card>
  );

  return (
    <>
      {/* Enhanced Floating Button with smart positioning */}
      {!isOpen && (
        <div 
          className={`fixed right-4 transition-all duration-500 ${
            isVisible ? "translate-y-0 opacity-100" : "translate-y-16 opacity-0"
          }`}
          style={{
            bottom: positioning.mobileBottomOffset,
            zIndex: positioning.zIndexValue
          }}
        >
          <Button
            onClick={() => setIsOpen(true)}
            className="relative w-16 h-16 rounded-full shadow-2xl bg-gradient-to-br from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 border-4 border-white transform transition-all duration-300 hover:scale-110 hover:shadow-3xl group touch-manipulation will-change-transform"
            size="lg"
            aria-label="M·ªü chat h·ªó tr·ª£"
            tabIndex={0}
          >
            {/* Ripple effect on hover */}
            <div className="absolute inset-0 rounded-full bg-white opacity-0 group-hover:opacity-20 group-hover:scale-110 transition-all duration-300" />
            
            <MessageCircle className="w-7 h-7 text-white transition-transform duration-200 group-hover:scale-110" aria-hidden="true" />
            
            {/* Enhanced notification badge with accessibility */}
            {unreadCount > 0 && (
              <Badge 
                className="absolute -top-2 -right-2 h-6 w-6 rounded-full p-0 bg-red-500 text-white text-xs font-bold border-2 border-white shadow-lg animate-pulse hover:animate-bounce will-change-transform"
                aria-label={`${unreadCount} tin nh·∫Øn ch∆∞a ƒë·ªçc`}
              >
                {unreadCount > 9 ? '9+' : unreadCount}
              </Badge>
            )}
            
            {/* Optimized breathing animation ring */}
            <div className="absolute inset-0 rounded-full border-2 border-green-400 opacity-50 animate-ping will-change-transform" aria-hidden="true" />
            
            {/* Online status indicator with accessibility */}
            <div 
              className="absolute bottom-1 right-1 w-4 h-4 bg-green-400 rounded-full border-2 border-white shadow-sm animate-pulse will-change-transform" 
              aria-label="Tr·∫°ng th√°i tr·ª±c tuy·∫øn"
              title="Tr·ª£ l√Ω ƒëang tr·ª±c tuy·∫øn"
            />
          </Button>
          
          {/* Enhanced tooltip with accessibility */}
          <div 
            className="absolute bottom-full right-0 mb-2 px-3 py-1 bg-gray-800 text-white text-sm rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 whitespace-nowrap pointer-events-none will-change-opacity"
            role="tooltip"
            aria-hidden="true"
          >
            C·∫ßn h·ªó tr·ª£? Chat ngay!
            <div className="absolute top-full right-4 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-800" />
          </div>
        </div>
      )}

      {/* Enhanced Chat Interface with smart positioning */}
      {isOpen && (
        <>
          {/* Mobile: Full screen overlay */}
          <div className="md:hidden">
            <MobileChat />
          </div>
          
          {/* Desktop: Popup window with smart positioning */}
          <div className="hidden md:block">
            <DesktopChat />
          </div>
        </>
      )}
    </>
  );
}