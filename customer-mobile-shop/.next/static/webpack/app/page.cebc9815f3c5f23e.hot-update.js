"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/addressStorage.ts":
/*!*************************************!*\
  !*** ./src/utils/addressStorage.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressStorage: () => (/* binding */ AddressStorage)\n/* harmony export */ });\nconst ADDRESSES_KEY = 'user_addresses';\nclass AddressStorage {\n    static generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    static getAddresses() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(ADDRESSES_KEY);\n            if (!stored) return [];\n            const addresses = JSON.parse(stored);\n            // Migrate legacy addresses to new format\n            const migratedAddresses = addresses.map((addr)=>{\n                // Case 1: Very old format with ward/district/city separate\n                if ('ward' in addr || 'district' in addr) {\n                    const legacy = addr;\n                    const fullAddress = [\n                        legacy.address,\n                        legacy.ward,\n                        legacy.district\n                    ].filter(Boolean).join(', ');\n                    return {\n                        id: legacy.id,\n                        name: legacy.name,\n                        phone: legacy.phone,\n                        address: \"\".concat(fullAddress, \", \").concat(legacy.city),\n                        isDefault: legacy.isDefault,\n                        createdAt: legacy.createdAt,\n                        updatedAt: new Date().toISOString()\n                    };\n                }\n                // Case 2: Previous format with separate fullAddress + city\n                if ('city' in addr && !('address' in addr)) {\n                    const prevFormat = addr;\n                    return {\n                        id: prevFormat.id,\n                        name: prevFormat.name,\n                        phone: prevFormat.phone,\n                        address: prevFormat.address ? \"\".concat(prevFormat.address, \", \").concat(prevFormat.city) : prevFormat.city,\n                        isDefault: prevFormat.isDefault,\n                        createdAt: prevFormat.createdAt,\n                        updatedAt: new Date().toISOString()\n                    };\n                }\n                // Case 3: Already new format, but ensure address field exists\n                const current = addr;\n                return {\n                    ...current,\n                    address: current.address || ''\n                };\n            });\n            // Save migrated addresses\n            if (migratedAddresses.length > 0) {\n                this.saveAddresses(migratedAddresses);\n            }\n            return migratedAddresses;\n        } catch (error) {\n            console.error('Failed to get addresses:', error);\n            return [];\n        }\n    }\n    static saveAddresses(addresses) {\n        if (false) {}\n        try {\n            localStorage.setItem(ADDRESSES_KEY, JSON.stringify(addresses));\n        } catch (error) {\n            console.error('Failed to save addresses:', error);\n        }\n    }\n    static addAddress(data) {\n        const addresses = this.getAddresses();\n        // If this is set as default, unset other defaults\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        // If this is the first address, make it default\n        const isFirstAddress = addresses.length === 0;\n        const newAddress = {\n            id: this.generateId(),\n            ...data,\n            isDefault: data.isDefault || isFirstAddress,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        addresses.push(newAddress);\n        this.saveAddresses(addresses);\n        return newAddress;\n    }\n    static updateAddress(id, data) {\n        const addresses = this.getAddresses();\n        const index = addresses.findIndex((addr)=>addr.id === id);\n        if (index === -1) return null;\n        // If setting as default, unset others\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        addresses[index] = {\n            ...addresses[index],\n            ...data,\n            updatedAt: new Date().toISOString()\n        };\n        this.saveAddresses(addresses);\n        return addresses[index];\n    }\n    static deleteAddress(id) {\n        const addresses = this.getAddresses();\n        const filteredAddresses = addresses.filter((addr)=>addr.id !== id);\n        if (filteredAddresses.length === addresses.length) {\n            return false; // Address not found\n        }\n        // If we deleted the default address, make the first remaining address default\n        const deletedAddress = addresses.find((addr)=>addr.id === id);\n        if ((deletedAddress === null || deletedAddress === void 0 ? void 0 : deletedAddress.isDefault) && filteredAddresses.length > 0) {\n            filteredAddresses[0].isDefault = true;\n        }\n        this.saveAddresses(filteredAddresses);\n        return true;\n    }\n    static setDefaultAddress(id) {\n        const addresses = this.getAddresses();\n        const targetAddress = addresses.find((addr)=>addr.id === id);\n        if (!targetAddress) return false;\n        // Unset all defaults and set the target as default\n        addresses.forEach((addr)=>{\n            addr.isDefault = addr.id === id;\n            if (addr.id === id) {\n                addr.updatedAt = new Date().toISOString();\n            }\n        });\n        this.saveAddresses(addresses);\n        return true;\n    }\n    static getDefaultAddress() {\n        const addresses = this.getAddresses();\n        return addresses.find((addr)=>addr.isDefault) || addresses[0] || null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hZGRyZXNzU3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsZ0JBQWdCO0FBZ0JmLE1BQU1DO0lBQ1gsT0FBZUMsYUFBcUI7UUFDbEMsT0FBT0MsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLENBQUMsTUFBTUMsS0FBS0MsTUFBTSxHQUFHRixRQUFRLENBQUMsSUFBSUcsTUFBTSxDQUFDO0lBQ3JFO0lBRUEsT0FBT0MsZUFBMEI7UUFDL0IsSUFBSSxLQUE2QixFQUFFLEVBQVU7UUFFN0MsSUFBSTtZQUNGLE1BQU1DLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ1o7WUFDcEMsSUFBSSxDQUFDVSxRQUFRLE9BQU8sRUFBRTtZQUV0QixNQUFNRyxZQUF5Q0MsS0FBS0MsS0FBSyxDQUFDTDtZQUUxRCx5Q0FBeUM7WUFDekMsTUFBTU0sb0JBQStCSCxVQUFVSSxHQUFHLENBQUNDLENBQUFBO2dCQUNqRCwyREFBMkQ7Z0JBQzNELElBQUksVUFBVUEsUUFBUSxjQUFjQSxNQUFNO29CQUN4QyxNQUFNQyxTQUFTRDtvQkFDZixNQUFNRSxjQUFjO3dCQUNsQkQsT0FBT0UsT0FBTzt3QkFDZEYsT0FBT0csSUFBSTt3QkFDWEgsT0FBT0ksUUFBUTtxQkFDaEIsQ0FBQ0MsTUFBTSxDQUFDQyxTQUFTQyxJQUFJLENBQUM7b0JBRXZCLE9BQU87d0JBQ0xDLElBQUlSLE9BQU9RLEVBQUU7d0JBQ2JDLE1BQU1ULE9BQU9TLElBQUk7d0JBQ2pCQyxPQUFPVixPQUFPVSxLQUFLO3dCQUNuQlIsU0FBUyxHQUFtQkYsT0FBaEJDLGFBQVksTUFBZ0IsT0FBWkQsT0FBT1csSUFBSTt3QkFDdkNDLFdBQVdaLE9BQU9ZLFNBQVM7d0JBQzNCQyxXQUFXYixPQUFPYSxTQUFTO3dCQUMzQkMsV0FBVyxJQUFJOUIsT0FBTytCLFdBQVc7b0JBQ25DO2dCQUNGO2dCQUVBLDJEQUEyRDtnQkFDM0QsSUFBSSxVQUFVaEIsUUFBUSxDQUFFLGNB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cy9hZGRyZXNzU3RvcmFnZS50cz9iMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkZHJlc3MsIEFkZEFkZHJlc3NEYXRhIH0gZnJvbSAnQC90eXBlcy9hZGRyZXNzJztcblxuY29uc3QgQUREUkVTU0VTX0tFWSA9ICd1c2VyX2FkZHJlc3Nlcyc7XG5cbi8vIExlZ2FjeSBhZGRyZXNzIGZvcm1hdCBmb3IgbWlncmF0aW9uXG5pbnRlcmZhY2UgTGVnYWN5QWRkcmVzcyB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB3YXJkPzogc3RyaW5nO1xuICBkaXN0cmljdD86IHN0cmluZztcbiAgY2l0eTogc3RyaW5nO1xuICBpc0RlZmF1bHQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICB1cGRhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEFkZHJlc3NTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBZGRyZXNzZXMoKTogQWRkcmVzc1tdIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQUREUkVTU0VTX0tFWSk7XG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIFtdO1xuICAgICAgXG4gICAgICBjb25zdCBhZGRyZXNzZXM6IChBZGRyZXNzIHwgTGVnYWN5QWRkcmVzcylbXSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgIFxuICAgICAgLy8gTWlncmF0ZSBsZWdhY3kgYWRkcmVzc2VzIHRvIG5ldyBmb3JtYXRcbiAgICAgIGNvbnN0IG1pZ3JhdGVkQWRkcmVzc2VzOiBBZGRyZXNzW10gPSBhZGRyZXNzZXMubWFwKGFkZHIgPT4ge1xuICAgICAgICAvLyBDYXNlIDE6IFZlcnkgb2xkIGZvcm1hdCB3aXRoIHdhcmQvZGlzdHJpY3QvY2l0eSBzZXBhcmF0ZVxuICAgICAgICBpZiAoJ3dhcmQnIGluIGFkZHIgfHwgJ2Rpc3RyaWN0JyBpbiBhZGRyKSB7XG4gICAgICAgICAgY29uc3QgbGVnYWN5ID0gYWRkciBhcyBMZWdhY3lBZGRyZXNzO1xuICAgICAgICAgIGNvbnN0IGZ1bGxBZGRyZXNzID0gW1xuICAgICAgICAgICAgbGVnYWN5LmFkZHJlc3MsXG4gICAgICAgICAgICBsZWdhY3kud2FyZCxcbiAgICAgICAgICAgIGxlZ2FjeS5kaXN0cmljdFxuICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBsZWdhY3kuaWQsXG4gICAgICAgICAgICBuYW1lOiBsZWdhY3kubmFtZSxcbiAgICAgICAgICAgIHBob25lOiBsZWdhY3kucGhvbmUsXG4gICAgICAgICAgICBhZGRyZXNzOiBgJHtmdWxsQWRkcmVzc30sICR7bGVnYWN5LmNpdHl9YCxcbiAgICAgICAgICAgIGlzRGVmYXVsdDogbGVnYWN5LmlzRGVmYXVsdCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbGVnYWN5LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBVcGRhdGUgdGltZXN0YW1wIGZvciBtaWdyYXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYXNlIDI6IFByZXZpb3VzIGZvcm1hdCB3aXRoIHNlcGFyYXRlIGZ1bGxBZGRyZXNzICsgY2l0eVxuICAgICAgICBpZiAoJ2NpdHknIGluIGFkZHIgJiYgISgnYWRkcmVzcycgaW4gYWRkcikpIHtcbiAgICAgICAgICBjb25zdCBwcmV2Rm9ybWF0ID0gYWRkciBhcyBhbnk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBwcmV2Rm9ybWF0LmlkLFxuICAgICAgICAgICAgbmFtZTogcHJldkZvcm1hdC5uYW1lLFxuICAgICAgICAgICAgcGhvbmU6IHByZXZGb3JtYXQucGhvbmUsXG4gICAgICAgICAgICBhZGRyZXNzOiBwcmV2Rm9ybWF0LmFkZHJlc3MgPyBgJHtwcmV2Rm9ybWF0LmFkZHJlc3N9LCAke3ByZXZGb3JtYXQuY2l0eX1gIDogcHJldkZvcm1hdC5jaXR5LFxuICAgICAgICAgICAgaXNEZWZhdWx0OiBwcmV2Rm9ybWF0LmlzRGVmYXVsdCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogcHJldkZvcm1hdC5jcmVhdGVkQXQsXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYXNlIDM6IEFscmVhZHkgbmV3IGZvcm1hdCwgYnV0IGVuc3VyZSBhZGRyZXNzIGZpZWxkIGV4aXN0c1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gYWRkciBhcyBBZGRyZXNzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmN1cnJlbnQsXG4gICAgICAgICAgYWRkcmVzczogY3VycmVudC5hZGRyZXNzIHx8ICcnLCAvLyBTYWZlZ3VhcmQgYWdhaW5zdCBtaXNzaW5nIGFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTYXZlIG1pZ3JhdGVkIGFkZHJlc3Nlc1xuICAgICAgaWYgKG1pZ3JhdGVkQWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zYXZlQWRkcmVzc2VzKG1pZ3JhdGVkQWRkcmVzc2VzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG1pZ3JhdGVkQWRkcmVzc2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGFkZHJlc3NlczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNhdmVBZGRyZXNzZXMoYWRkcmVzc2VzOiBBZGRyZXNzW10pOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQUREUkVTU0VTX0tFWSwgSlNPTi5zdHJpbmdpZnkoYWRkcmVzc2VzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGFkZHJlc3NlczonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFkZEFkZHJlc3MoZGF0YTogQWRkQWRkcmVzc0RhdGEpOiBBZGRyZXNzIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLmdldEFkZHJlc3NlcygpO1xuICAgIFxuICAgIC8vIElmIHRoaXMgaXMgc2V0IGFzIGRlZmF1bHQsIHVuc2V0IG90aGVyIGRlZmF1bHRzXG4gICAgaWYgKGRhdGEuaXNEZWZhdWx0KSB7XG4gICAgICBhZGRyZXNzZXMuZm9yRWFjaChhZGRyID0+IGFkZHIuaXNEZWZhdWx0ID0gZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBhZGRyZXNzLCBtYWtlIGl0IGRlZmF1bHRcbiAgICBjb25zdCBpc0ZpcnN0QWRkcmVzcyA9IGFkZHJlc3Nlcy5sZW5ndGggPT09IDA7XG4gICAgXG4gICAgY29uc3QgbmV3QWRkcmVzczogQWRkcmVzcyA9IHtcbiAgICAgIGlkOiB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpc0RlZmF1bHQ6IGRhdGEuaXNEZWZhdWx0IHx8IGlzRmlyc3RBZGRyZXNzLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgYWRkcmVzc2VzLnB1c2gobmV3QWRkcmVzcyk7XG4gICAgdGhpcy5zYXZlQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG4gICAgXG4gICAgcmV0dXJuIG5ld0FkZHJlc3M7XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlQWRkcmVzcyhpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPEFkZEFkZHJlc3NEYXRhPik6IEFkZHJlc3MgfCBudWxsIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLmdldEFkZHJlc3NlcygpO1xuICAgIGNvbnN0IGluZGV4ID0gYWRkcmVzc2VzLmZpbmRJbmRleChhZGRyID0+IGFkZHIuaWQgPT09IGlkKTtcbiAgICBcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICAvLyBJZiBzZXR0aW5nIGFzIGRlZmF1bHQsIHVuc2V0IG90aGVyc1xuICAgIGlmIChkYXRhLmlzRGVmYXVsdCkge1xuICAgICAgYWRkcmVzc2VzLmZvckVhY2goYWRkciA9PiBhZGRyLmlzRGVmYXVsdCA9IGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgYWRkcmVzc2VzW2luZGV4XSA9IHtcbiAgICAgIC4uLmFkZHJlc3Nlc1tpbmRleF0sXG4gICAgICAuLi5kYXRhLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNhdmVBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICByZXR1cm4gYWRkcmVzc2VzW2luZGV4XTtcbiAgfVxuXG4gIHN0YXRpYyBkZWxldGVBZGRyZXNzKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLmdldEFkZHJlc3NlcygpO1xuICAgIGNvbnN0IGZpbHRlcmVkQWRkcmVzc2VzID0gYWRkcmVzc2VzLmZpbHRlcihhZGRyID0+IGFkZHIuaWQgIT09IGlkKTtcbiAgICBcbiAgICBpZiAoZmlsdGVyZWRBZGRyZXNzZXMubGVuZ3RoID09PSBhZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEFkZHJlc3Mgbm90IGZvdW5kXG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIGRlbGV0ZWQgdGhlIGRlZmF1bHQgYWRkcmVzcywgbWFrZSB0aGUgZmlyc3QgcmVtYWluaW5nIGFkZHJlc3MgZGVmYXVsdFxuICAgIGNvbnN0IGRlbGV0ZWRBZGRyZXNzID0gYWRkcmVzc2VzLmZpbmQoYWRkciA9PiBhZGRyLmlkID09PSBpZCk7XG4gICAgaWYgKGRlbGV0ZWRBZGRyZXNzPy5pc0RlZmF1bHQgJiYgZmlsdGVyZWRBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgZmlsdGVyZWRBZGRyZXNzZXNbMF0uaXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zYXZlQWRkcmVzc2VzKGZpbHRlcmVkQWRkcmVzc2VzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBzZXREZWZhdWx0QWRkcmVzcyhpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gdGhpcy5nZXRBZGRyZXNzZXMoKTtcbiAgICBjb25zdCB0YXJnZXRBZGRyZXNzID0gYWRkcmVzc2VzLmZpbmQoYWRkciA9PiBhZGRyLmlkID09PSBpZCk7XG4gICAgXG4gICAgaWYgKCF0YXJnZXRBZGRyZXNzKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gVW5zZXQgYWxsIGRlZmF1bHRzIGFuZCBzZXQgdGhlIHRhcmdldCBhcyBkZWZhdWx0XG4gICAgYWRkcmVzc2VzLmZvckVhY2goYWRkciA9PiB7XG4gICAgICBhZGRyLmlzRGVmYXVsdCA9IGFkZHIuaWQgPT09IGlkO1xuICAgICAgaWYgKGFkZHIuaWQgPT09IGlkKSB7XG4gICAgICAgIGFkZHIudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuc2F2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldERlZmF1bHRBZGRyZXNzKCk6IEFkZHJlc3MgfCBudWxsIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLmdldEFkZHJlc3NlcygpO1xuICAgIHJldHVybiBhZGRyZXNzZXMuZmluZChhZGRyID0+IGFkZHIuaXNEZWZhdWx0KSB8fCBhZGRyZXNzZXNbMF0gfHwgbnVsbDtcbiAgfVxufSJdLCJuYW1lcyI6WyJBRERSRVNTRVNfS0VZIiwiQWRkcmVzc1N0b3JhZ2UiLCJnZW5lcmF0ZUlkIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInN1YnN0ciIsImdldEFkZHJlc3NlcyIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhZGRyZXNzZXMiLCJKU09OIiwicGFyc2UiLCJtaWdyYXRlZEFkZHJlc3NlcyIsIm1hcCIsImFkZHIiLCJsZWdhY3kiLCJmdWxsQWRkcmVzcyIsImFkZHJlc3MiLCJ3YXJkIiwiZGlzdHJpY3QiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImlkIiwibmFtZSIsInBob25lIiwiY2l0eSIsImlzRGVmYXVsdCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInRvSVNPU3RyaW5nIiwicHJldkZvcm1hdCIsImN1cnJlbnQiLCJsZW5ndGgiLCJzYXZlQWRkcmVzc2VzIiwiZXJyb3IiLCJjb25zb2xlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImFkZEFkZHJlc3MiLCJkYXRhIiwiZm9yRWFjaCIsImlzRmlyc3RBZGRyZXNzIiwibmV3QWRkcmVzcyIsInB1c2giLCJ1cGRhdGVBZGRyZXNzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJkZWxldGVBZGRyZXNzIiwiZmlsdGVyZWRBZGRyZXNzZXMiLCJkZWxldGVkQWRkcmVzcyIsImZpbmQiLCJzZXREZWZhdWx0QWRkcmVzcyIsInRhcmdldEFkZHJlc3MiLCJnZXREZWZhdWx0QWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/addressStorage.ts\n"));

/***/ })

});