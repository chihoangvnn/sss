"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/addressStorage.ts":
/*!*************************************!*\
  !*** ./src/utils/addressStorage.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressStorage: () => (/* binding */ AddressStorage)\n/* harmony export */ });\nconst ADDRESSES_KEY = 'user_addresses';\nclass AddressStorage {\n    static generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    static getAddresses() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(ADDRESSES_KEY);\n            return stored ? JSON.parse(stored) : [];\n        } catch (error) {\n            console.error('Failed to get addresses:', error);\n            return [];\n        }\n    }\n    static saveAddresses(addresses) {\n        if (false) {}\n        try {\n            localStorage.setItem(ADDRESSES_KEY, JSON.stringify(addresses));\n        } catch (error) {\n            console.error('Failed to save addresses:', error);\n        }\n    }\n    static addAddress(data) {\n        const addresses = this.getAddresses();\n        // If this is set as default, unset other defaults\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        // If this is the first address, make it default\n        const isFirstAddress = addresses.length === 0;\n        const newAddress = {\n            id: this.generateId(),\n            ...data,\n            isDefault: data.isDefault || isFirstAddress,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        addresses.push(newAddress);\n        this.saveAddresses(addresses);\n        return newAddress;\n    }\n    static updateAddress(id, data) {\n        const addresses = this.getAddresses();\n        const index = addresses.findIndex((addr)=>addr.id === id);\n        if (index === -1) return null;\n        // If setting as default, unset others\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        addresses[index] = {\n            ...addresses[index],\n            ...data,\n            updatedAt: new Date().toISOString()\n        };\n        this.saveAddresses(addresses);\n        return addresses[index];\n    }\n    static deleteAddress(id) {\n        const addresses = this.getAddresses();\n        const filteredAddresses = addresses.filter((addr)=>addr.id !== id);\n        if (filteredAddresses.length === addresses.length) {\n            return false; // Address not found\n        }\n        // If we deleted the default address, make the first remaining address default\n        const deletedAddress = addresses.find((addr)=>addr.id === id);\n        if ((deletedAddress === null || deletedAddress === void 0 ? void 0 : deletedAddress.isDefault) && filteredAddresses.length > 0) {\n            filteredAddresses[0].isDefault = true;\n        }\n        this.saveAddresses(filteredAddresses);\n        return true;\n    }\n    static setDefaultAddress(id) {\n        const addresses = this.getAddresses();\n        const targetAddress = addresses.find((addr)=>addr.id === id);\n        if (!targetAddress) return false;\n        // Unset all defaults and set the target as default\n        addresses.forEach((addr)=>{\n            addr.isDefault = addr.id === id;\n            if (addr.id === id) {\n                addr.updatedAt = new Date().toISOString();\n            }\n        });\n        this.saveAddresses(addresses);\n        return true;\n    }\n    static getDefaultAddress() {\n        const addresses = this.getAddresses();\n        return addresses.find((addr)=>addr.isDefault) || addresses[0] || null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hZGRyZXNzU3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsZ0JBQWdCO0FBZ0JmLE1BQU1DO0lBQ1gsT0FBZUMsYUFBcUI7UUFDbEMsT0FBT0MsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLENBQUMsTUFBTUMsS0FBS0MsTUFBTSxHQUFHRixRQUFRLENBQUMsSUFBSUcsTUFBTSxDQUFDO0lBQ3JFO0lBRUEsT0FBT0MsZUFBMEI7UUFDL0IsSUFBSSxLQUE2QixFQUFFLEVBQVU7UUFFN0MsSUFBSTtZQUNGLE1BQU1DLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ1o7WUFDcEMsT0FBT1UsU0FBU0csS0FBS0MsS0FBSyxDQUFDSixVQUFVLEVBQUU7UUFDekMsRUFBRSxPQUFPSyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO1lBQzFDLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxPQUFPRSxjQUFjQyxTQUFvQixFQUFRO1FBQy9DLElBQUksS0FBNkIsRUFBRSxFQUFPO1FBRTFDLElBQUk7WUFDRlAsYUFBYVEsT0FBTyxDQUFDbkIsZUFBZWEsS0FBS08sU0FBUyxDQUFDRjtRQUNyRCxFQUFFLE9BQU9ILE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7UUFDN0M7SUFDRjtJQUVBLE9BQU9NLFdBQVdDLElBQW9CLEVBQVc7UUFDL0MsTUFBTUosWUFBWSxJQUFJLENBQUNULFlBQVk7UUFFbkMsa0RBQWtEO1FBQ2xELElBQUlhLEtBQUtDLFNBQVMsRUFBRTtZQUNsQkwsVUFBVU0sT0FBTyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLRixTQUFTLEdBQUc7UUFDN0M7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTUcsaUJBQWlCUixVQUFVUyxNQUFNLEtBQUs7UUFFNUMsTUFBTUMsYUFBc0I7WUFDMUJDLElBQUksSUFBSSxDQUFDM0IsVUFBVTtZQUNuQixHQUFHb0IsSUFBSTtZQUNQQyxXQUFXRCxLQUFLQyxTQUFTLElBQUlHO1lBQzdCSSxXQUFXLElBQUkzQixPQUFPNEIsV0FBVztZQUNqQ0MsV0FBVyxJQUFJN0IsT0FBTzRCLFdBQVc7UUFDbkM7UUFFQWIsVUFBVWUsSUFBSSxDQUFDTDtRQUNmLElBQUksQ0FBQ1gsYUFBYSxDQUFDQztRQUVuQixPQUFPVTtJQUNUO0lBRUEsT0FBT00sY0FBY0wsRUFBVSxFQUFFUCxJQUE2QixFQUFrQjtRQUM5RSxNQUFNSixZQUFZLElBQUksQ0FBQ1QsWUFBWTtRQUNuQyxNQUFNMEIsUUFBUWpCLFVBQVVrQixTQUFTLENBQUNYLENBQUFBLE9BQVFBLEtBQUtJLEVBQUUsS0FBS0E7UUFFdEQsSUFBSU0sVUFBVSxDQUFDLEdBQUcsT0FBTztRQUV6QixzQ0FBc0M7UUFDdEMsSUFBSWIsS0FBS0MsU0FBUyxFQUFFO1lBQ2xCTCxVQUFVTSxPQUFPLENBQUNDLENBQUFBLE9BQVFBLEtBQUtGLFNBQVMsR0FBRztRQUM3QztRQUVBTCxTQUFTLENBQUNpQixNQUFNLEdBQUc7WUFDakIsR0FBR2pCLFNBQVMsQ0FBQ2lCLE1BQU07WUFDbkIsR0FBR2IsSUFBSTtZQUNQVSxXQUFXLElBQUk3QixPQUFPNEIsV0FBVztRQUNuQztRQUVBLElBQUksQ0FBQ2QsYUFBYSxDQUFDQztRQUNuQixPQUFPQSxTQUFTLENBQUNpQixNQUFNO0lBQ3pCO0lBRUEsT0FBT0UsY0FBY1IsRUFBVSxFQUFXO1FBQ3hDLE1BQU1YLFlBQVksSUFBSSxDQUFDVCxZQUFZO1FBQ25DLE1BQU02QixvQkFBb0JwQixVQUFVcUIsTUFBTSxDQUFDZCxDQUFBQSxPQUFRQSxLQUFLSSxFQUFFLEtBQUtBO1FBRS9ELElBQUlTLGtCQUFrQlgsTUFBTSxLQUFLVCxVQUFVUyxNQUFNLEVBQUU7WUFDakQsT0FBTyxPQUFPLG9CQUFvQjtRQUNwQztRQUVBLDhFQUE4RTtRQUM5RSxNQUFNYSxpQkFBaUJ0QixVQUFVdUIsSUFBSSxDQUFDaEIsQ0FBQUEsT0FBUUEsS0FBS0ksRUFBRSxLQUFLQTtRQUMxRCxJQUFJVyxDQUFBQSwyQkFBQUEscUNBQUFBLGVBQWdCakIsU0FBUyxLQUFJZSxrQkFBa0JYLE1BQU0sR0FBRyxHQUFHO1lBQzdEVyxpQkFBaUIsQ0FBQyxFQUFFLENBQUNmLFNBQVMsR0FBRztRQUNuQztRQUVBLElBQUksQ0FBQ04sYUFBYSxDQUFDcUI7UUFDbkIsT0FBTztJQUNUO0lBRUEsT0FBT0ksa0JBQWtCYixFQUFVLEVBQVc7UUFDNUMsTUFBTVgsWUFBWSxJQUFJLENBQUNULFlBQVk7UUFDbkMsTUFBTWtDLGdCQUFnQnpCLFVBQVV1QixJQUFJLENBQUNoQixDQUFBQSxPQUFRQSxLQUFLSSxFQUFFLEtBQUtBO1FBRXpELElBQUksQ0FBQ2MsZUFBZSxPQUFPO1FBRTNCLG1EQUFtRDtRQUNuRHpCLFVBQVVNLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDaEJBLEtBQUtGLFNBQVMsR0FBR0UsS0FBS0ksRUFBRSxLQUFLQTtZQUM3QixJQUFJSixLQUFLSSxFQUFFLEtBQUtBLElBQUk7Z0JBQ2xCSixLQUFLTyxTQUFTLEdBQUcsSUFBSTdCLE9BQU80QixXQUFXO1lBQ3pDO1FBQ0Y7UUFFQSxJQUFJLENBQUNkLGFBQWEsQ0FBQ0M7UUFDbkIsT0FBTztJQUNUO0lBRUEsT0FBTzBCLG9CQUFvQztRQUN6QyxNQUFNMUIsWUFBWSxJQUFJLENBQUNULFlBQVk7UUFDbkMsT0FBT1MsVUFBVXVCLElBQUksQ0FBQ2hCLENBQUFBLE9BQVFBLEtBQUtGLFNBQVMsS0FBS0wsU0FBUyxDQUFDLEVBQUUsSUFBSTtJQUNuRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9hZGRyZXNzU3RvcmFnZS50cz9iMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkZHJlc3MsIEFkZEFkZHJlc3NEYXRhIH0gZnJvbSAnQC90eXBlcy9hZGRyZXNzJztcblxuY29uc3QgQUREUkVTU0VTX0tFWSA9ICd1c2VyX2FkZHJlc3Nlcyc7XG5cbi8vIExlZ2FjeSBhZGRyZXNzIGZvcm1hdCBmb3IgbWlncmF0aW9uXG5pbnRlcmZhY2UgTGVnYWN5QWRkcmVzcyB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB3YXJkPzogc3RyaW5nO1xuICBkaXN0cmljdD86IHN0cmluZztcbiAgY2l0eTogc3RyaW5nO1xuICBpc0RlZmF1bHQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICB1cGRhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEFkZHJlc3NTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBZGRyZXNzZXMoKTogQWRkcmVzc1tdIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQUREUkVTU0VTX0tFWSk7XG4gICAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWRkcmVzc2VzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2F2ZUFkZHJlc3NlcyhhZGRyZXNzZXM6IEFkZHJlc3NbXSk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBRERSRVNTRVNfS0VZLCBKU09OLnN0cmluZ2lmeShhZGRyZXNzZXMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgYWRkcmVzc2VzOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWRkQWRkcmVzcyhkYXRhOiBBZGRBZGRyZXNzRGF0YSk6IEFkZHJlc3Mge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgXG4gICAgLy8gSWYgdGhpcyBpcyBzZXQgYXMgZGVmYXVsdCwgdW5zZXQgb3RoZXIgZGVmYXVsdHNcbiAgICBpZiAoZGF0YS5pc0RlZmF1bHQpIHtcbiAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHIgPT4gYWRkci5pc0RlZmF1bHQgPSBmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGFkZHJlc3MsIG1ha2UgaXQgZGVmYXVsdFxuICAgIGNvbnN0IGlzRmlyc3RBZGRyZXNzID0gYWRkcmVzc2VzLmxlbmd0aCA9PT0gMDtcbiAgICBcbiAgICBjb25zdCBuZXdBZGRyZXNzOiBBZGRyZXNzID0ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgLi4uZGF0YSxcbiAgICAgIGlzRGVmYXVsdDogZGF0YS5pc0RlZmF1bHQgfHwgaXNGaXJzdEFkZHJlc3MsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBhZGRyZXNzZXMucHVzaChuZXdBZGRyZXNzKTtcbiAgICB0aGlzLnNhdmVBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICBcbiAgICByZXR1cm4gbmV3QWRkcmVzcztcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVBZGRyZXNzKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8QWRkQWRkcmVzc0RhdGE+KTogQWRkcmVzcyB8IG51bGwge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3QgaW5kZXggPSBhZGRyZXNzZXMuZmluZEluZGV4KGFkZHIgPT4gYWRkci5pZCA9PT0gaWQpO1xuICAgIFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBudWxsO1xuICAgIFxuICAgIC8vIElmIHNldHRpbmcgYXMgZGVmYXVsdCwgdW5zZXQgb3RoZXJzXG4gICAgaWYgKGRhdGEuaXNEZWZhdWx0KSB7XG4gICAgICBhZGRyZXNzZXMuZm9yRWFjaChhZGRyID0+IGFkZHIuaXNEZWZhdWx0ID0gZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICBhZGRyZXNzZXNbaW5kZXhdID0ge1xuICAgICAgLi4uYWRkcmVzc2VzW2luZGV4XSxcbiAgICAgIC4uLmRhdGEsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2F2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIHJldHVybiBhZGRyZXNzZXNbaW5kZXhdO1xuICB9XG5cbiAgc3RhdGljIGRlbGV0ZUFkZHJlc3MoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3QgZmlsdGVyZWRBZGRyZXNzZXMgPSBhZGRyZXNzZXMuZmlsdGVyKGFkZHIgPT4gYWRkci5pZCAhPT0gaWQpO1xuICAgIFxuICAgIGlmIChmaWx0ZXJlZEFkZHJlc3Nlcy5sZW5ndGggPT09IGFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gQWRkcmVzcyBub3QgZm91bmRcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UgZGVsZXRlZCB0aGUgZGVmYXVsdCBhZGRyZXNzLCBtYWtlIHRoZSBmaXJzdCByZW1haW5pbmcgYWRkcmVzcyBkZWZhdWx0XG4gICAgY29uc3QgZGVsZXRlZEFkZHJlc3MgPSBhZGRyZXNzZXMuZmluZChhZGRyID0+IGFkZHIuaWQgPT09IGlkKTtcbiAgICBpZiAoZGVsZXRlZEFkZHJlc3M/LmlzRGVmYXVsdCAmJiBmaWx0ZXJlZEFkZHJlc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBmaWx0ZXJlZEFkZHJlc3Nlc1swXS5pc0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhdmVBZGRyZXNzZXMoZmlsdGVyZWRBZGRyZXNzZXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIHNldERlZmF1bHRBZGRyZXNzKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLmdldEFkZHJlc3NlcygpO1xuICAgIGNvbnN0IHRhcmdldEFkZHJlc3MgPSBhZGRyZXNzZXMuZmluZChhZGRyID0+IGFkZHIuaWQgPT09IGlkKTtcbiAgICBcbiAgICBpZiAoIXRhcmdldEFkZHJlc3MpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBVbnNldCBhbGwgZGVmYXVsdHMgYW5kIHNldCB0aGUgdGFyZ2V0IGFzIGRlZmF1bHRcbiAgICBhZGRyZXNzZXMuZm9yRWFjaChhZGRyID0+IHtcbiAgICAgIGFkZHIuaXNEZWZhdWx0ID0gYWRkci5pZCA9PT0gaWQ7XG4gICAgICBpZiAoYWRkci5pZCA9PT0gaWQpIHtcbiAgICAgICAgYWRkci51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5zYXZlQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVmYXVsdEFkZHJlc3MoKTogQWRkcmVzcyB8IG51bGwge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5maW5kKGFkZHIgPT4gYWRkci5pc0RlZmF1bHQpIHx8IGFkZHJlc3Nlc1swXSB8fCBudWxsO1xuICB9XG59Il0sIm5hbWVzIjpbIkFERFJFU1NFU19LRVkiLCJBZGRyZXNzU3RvcmFnZSIsImdlbmVyYXRlSWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyIiwiZ2V0QWRkcmVzc2VzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsInNhdmVBZGRyZXNzZXMiLCJhZGRyZXNzZXMiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiYWRkQWRkcmVzcyIsImRhdGEiLCJpc0RlZmF1bHQiLCJmb3JFYWNoIiwiYWRkciIsImlzRmlyc3RBZGRyZXNzIiwibGVuZ3RoIiwibmV3QWRkcmVzcyIsImlkIiwiY3JlYXRlZEF0IiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJwdXNoIiwidXBkYXRlQWRkcmVzcyIsImluZGV4IiwiZmluZEluZGV4IiwiZGVsZXRlQWRkcmVzcyIsImZpbHRlcmVkQWRkcmVzc2VzIiwiZmlsdGVyIiwiZGVsZXRlZEFkZHJlc3MiLCJmaW5kIiwic2V0RGVmYXVsdEFkZHJlc3MiLCJ0YXJnZXRBZGRyZXNzIiwiZ2V0RGVmYXVsdEFkZHJlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/addressStorage.ts\n"));

/***/ })

});