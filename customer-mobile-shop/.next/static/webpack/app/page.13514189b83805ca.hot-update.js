"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/addressStorage.ts":
/*!*************************************!*\
  !*** ./src/utils/addressStorage.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressStorage: () => (/* binding */ AddressStorage)\n/* harmony export */ });\nconst ADDRESSES_KEY = 'user_addresses';\nclass AddressStorage {\n    static generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    static getAddresses() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(ADDRESSES_KEY);\n            if (!stored) return [];\n            const addresses = JSON.parse(stored);\n            // Migrate legacy addresses to new format\n            const migratedAddresses = addresses.map((addr)=>{\n                // If it's already new format, return as is\n                if (!('ward' in addr || 'district' in addr)) {\n                    return addr;\n                }\n                // Convert legacy format to new format\n                const legacy = addr;\n                const fullAddress = [\n                    legacy.address,\n                    legacy.ward,\n                    legacy.district\n                ].filter(Boolean).join(', ');\n                return {\n                    id: legacy.id,\n                    name: legacy.name,\n                    phone: legacy.phone,\n                    address: fullAddress,\n                    city: legacy.city,\n                    isDefault: legacy.isDefault,\n                    createdAt: legacy.createdAt,\n                    updatedAt: new Date().toISOString()\n                };\n            });\n            // Save migrated addresses\n            if (migratedAddresses.length > 0) {\n                this.saveAddresses(migratedAddresses);\n            }\n            return migratedAddresses;\n        } catch (error) {\n            console.error('Failed to get addresses:', error);\n            return [];\n        }\n    }\n    static saveAddresses(addresses) {\n        if (false) {}\n        try {\n            localStorage.setItem(ADDRESSES_KEY, JSON.stringify(addresses));\n        } catch (error) {\n            console.error('Failed to save addresses:', error);\n        }\n    }\n    static addAddress(data) {\n        const addresses = this.getAddresses();\n        // If this is set as default, unset other defaults\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        // If this is the first address, make it default\n        const isFirstAddress = addresses.length === 0;\n        const newAddress = {\n            id: this.generateId(),\n            ...data,\n            isDefault: data.isDefault || isFirstAddress,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        addresses.push(newAddress);\n        this.saveAddresses(addresses);\n        return newAddress;\n    }\n    static updateAddress(id, data) {\n        const addresses = this.getAddresses();\n        const index = addresses.findIndex((addr)=>addr.id === id);\n        if (index === -1) return null;\n        // If setting as default, unset others\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        addresses[index] = {\n            ...addresses[index],\n            ...data,\n            updatedAt: new Date().toISOString()\n        };\n        this.saveAddresses(addresses);\n        return addresses[index];\n    }\n    static deleteAddress(id) {\n        const addresses = this.getAddresses();\n        const filteredAddresses = addresses.filter((addr)=>addr.id !== id);\n        if (filteredAddresses.length === addresses.length) {\n            return false; // Address not found\n        }\n        // If we deleted the default address, make the first remaining address default\n        const deletedAddress = addresses.find((addr)=>addr.id === id);\n        if ((deletedAddress === null || deletedAddress === void 0 ? void 0 : deletedAddress.isDefault) && filteredAddresses.length > 0) {\n            filteredAddresses[0].isDefault = true;\n        }\n        this.saveAddresses(filteredAddresses);\n        return true;\n    }\n    static setDefaultAddress(id) {\n        const addresses = this.getAddresses();\n        const targetAddress = addresses.find((addr)=>addr.id === id);\n        if (!targetAddress) return false;\n        // Unset all defaults and set the target as default\n        addresses.forEach((addr)=>{\n            addr.isDefault = addr.id === id;\n            if (addr.id === id) {\n                addr.updatedAt = new Date().toISOString();\n            }\n        });\n        this.saveAddresses(addresses);\n        return true;\n    }\n    static getDefaultAddress() {\n        const addresses = this.getAddresses();\n        return addresses.find((addr)=>addr.isDefault) || addresses[0] || null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hZGRyZXNzU3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsZ0JBQWdCO0FBZ0JmLE1BQU1DO0lBQ1gsT0FBZUMsYUFBcUI7UUFDbEMsT0FBT0MsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLENBQUMsTUFBTUMsS0FBS0MsTUFBTSxHQUFHRixRQUFRLENBQUMsSUFBSUcsTUFBTSxDQUFDO0lBQ3JFO0lBRUEsT0FBT0MsZUFBMEI7UUFDL0IsSUFBSSxLQUE2QixFQUFFLEVBQVU7UUFFN0MsSUFBSTtZQUNGLE1BQU1DLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ1o7WUFDcEMsSUFBSSxDQUFDVSxRQUFRLE9BQU8sRUFBRTtZQUV0QixNQUFNRyxZQUF5Q0MsS0FBS0MsS0FBSyxDQUFDTDtZQUUxRCx5Q0FBeUM7WUFDekMsTUFBTU0sb0JBQStCSCxVQUFVSSxHQUFHLENBQUNDLENBQUFBO2dCQUNqRCwyQ0FBMkM7Z0JBQzNDLElBQUksQ0FBRSxXQUFVQSxRQUFRLGNBQWNBLElBQUcsR0FBSTtvQkFDM0MsT0FBT0E7Z0JBQ1Q7Z0JBRUEsc0NBQXNDO2dCQUN0QyxNQUFNQyxTQUFTRDtnQkFDZixNQUFNRSxjQUFjO29CQUNsQkQsT0FBT0UsT0FBTztvQkFDZEYsT0FBT0csSUFBSTtvQkFDWEgsT0FBT0ksUUFBUTtpQkFDaEIsQ0FBQ0MsTUFBTSxDQUFDQyxTQUFTQyxJQUFJLENBQUM7Z0JBRXZCLE9BQU87b0JBQ0xDLElBQUlSLE9BQU9RLEVBQUU7b0JBQ2JDLE1BQU1ULE9BQU9TLElBQUk7b0JBQ2pCQyxPQUFPVixPQUFPVSxLQUFLO29CQUNuQlIsU0FBU0Q7b0JBQ1RVLE1BQU1YLE9BQU9XLElBQUk7b0JBQ2pCQyxXQUFXWixPQUFPWSxTQUFTO29CQUMzQkMsV0FBV2IsT0FBT2EsU0FBUztvQkFDM0JDLFdBQVcsSUFBSTlCLE9BQU8rQixXQUFXO2dCQUNuQztZQUNGO1lBRUEsMEJBQTBCO1lBQzFCLElB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Q0FBQUEsT0FBUUEsS0FBS1MsRUFBRSxLQUFLQTtRQUV6RCxJQUFJLENBQUM0QixlQUFlLE9BQU87UUFFM0IsbURBQW1EO1FBQ25EMUMsVUFBVThCLE9BQU8sQ0FBQ3pCLENBQUFBO1lBQ2hCQSxLQUFLYSxTQUFTLEdBQUdiLEtBQUtTLEVBQUUsS0FBS0E7WUFDN0IsSUFBSVQsS0FBS1MsRUFBRSxLQUFLQSxJQUFJO2dCQUNsQlQsS0FBS2UsU0FBUyxHQUFHLElBQUk5QixPQUFPK0IsV0FBVztZQUN6QztRQUNGO1FBRUEsSUFBSSxDQUFDRSxhQUFhLENBQUN2QjtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxPQUFPMkMsb0JBQW9DO1FBQ3pDLE1BQU0zQyxZQUFZLElBQUksQ0FBQ0osWUFBWTtRQUNuQyxPQUFPSSxVQUFVd0MsSUFBSSxDQUFDbkMsQ0FBQUEsT0FBUUEsS0FBS2EsU0FBUyxLQUFLbEIsU0FBUyxDQUFDLEVBQUUsSUFBSTtJQUNuRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9hZGRyZXNzU3RvcmFnZS50cz9iMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkZHJlc3MsIEFkZEFkZHJlc3NEYXRhIH0gZnJvbSAnQC90eXBlcy9hZGRyZXNzJztcblxuY29uc3QgQUREUkVTU0VTX0tFWSA9ICd1c2VyX2FkZHJlc3Nlcyc7XG5cbi8vIExlZ2FjeSBhZGRyZXNzIGZvcm1hdCBmb3IgbWlncmF0aW9uXG5pbnRlcmZhY2UgTGVnYWN5QWRkcmVzcyB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB3YXJkPzogc3RyaW5nO1xuICBkaXN0cmljdD86IHN0cmluZztcbiAgY2l0eTogc3RyaW5nO1xuICBpc0RlZmF1bHQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICB1cGRhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEFkZHJlc3NTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBZGRyZXNzZXMoKTogQWRkcmVzc1tdIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQUREUkVTU0VTX0tFWSk7XG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIFtdO1xuICAgICAgXG4gICAgICBjb25zdCBhZGRyZXNzZXM6IChBZGRyZXNzIHwgTGVnYWN5QWRkcmVzcylbXSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgIFxuICAgICAgLy8gTWlncmF0ZSBsZWdhY3kgYWRkcmVzc2VzIHRvIG5ldyBmb3JtYXRcbiAgICAgIGNvbnN0IG1pZ3JhdGVkQWRkcmVzc2VzOiBBZGRyZXNzW10gPSBhZGRyZXNzZXMubWFwKGFkZHIgPT4ge1xuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgbmV3IGZvcm1hdCwgcmV0dXJuIGFzIGlzXG4gICAgICAgIGlmICghKCd3YXJkJyBpbiBhZGRyIHx8ICdkaXN0cmljdCcgaW4gYWRkcikpIHtcbiAgICAgICAgICByZXR1cm4gYWRkciBhcyBBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IGxlZ2FjeSBmb3JtYXQgdG8gbmV3IGZvcm1hdFxuICAgICAgICBjb25zdCBsZWdhY3kgPSBhZGRyIGFzIExlZ2FjeUFkZHJlc3M7XG4gICAgICAgIGNvbnN0IGZ1bGxBZGRyZXNzID0gW1xuICAgICAgICAgIGxlZ2FjeS5hZGRyZXNzLFxuICAgICAgICAgIGxlZ2FjeS53YXJkLFxuICAgICAgICAgIGxlZ2FjeS5kaXN0cmljdFxuICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogbGVnYWN5LmlkLFxuICAgICAgICAgIG5hbWU6IGxlZ2FjeS5uYW1lLFxuICAgICAgICAgIHBob25lOiBsZWdhY3kucGhvbmUsXG4gICAgICAgICAgYWRkcmVzczogZnVsbEFkZHJlc3MsXG4gICAgICAgICAgY2l0eTogbGVnYWN5LmNpdHksXG4gICAgICAgICAgaXNEZWZhdWx0OiBsZWdhY3kuaXNEZWZhdWx0LFxuICAgICAgICAgIGNyZWF0ZWRBdDogbGVnYWN5LmNyZWF0ZWRBdCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgLy8gVXBkYXRlIHRpbWVzdGFtcCBmb3IgbWlncmF0aW9uXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSBtaWdyYXRlZCBhZGRyZXNzZXNcbiAgICAgIGlmIChtaWdyYXRlZEFkZHJlc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2F2ZUFkZHJlc3NlcyhtaWdyYXRlZEFkZHJlc3Nlcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBtaWdyYXRlZEFkZHJlc3NlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBhZGRyZXNzZXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBzYXZlQWRkcmVzc2VzKGFkZHJlc3NlczogQWRkcmVzc1tdKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFERFJFU1NFU19LRVksIEpTT04uc3RyaW5naWZ5KGFkZHJlc3NlcykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBhZGRyZXNzZXM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhZGRBZGRyZXNzKGRhdGE6IEFkZEFkZHJlc3NEYXRhKTogQWRkcmVzcyB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gdGhpcy5nZXRBZGRyZXNzZXMoKTtcbiAgICBcbiAgICAvLyBJZiB0aGlzIGlzIHNldCBhcyBkZWZhdWx0LCB1bnNldCBvdGhlciBkZWZhdWx0c1xuICAgIGlmIChkYXRhLmlzRGVmYXVsdCkge1xuICAgICAgYWRkcmVzc2VzLmZvckVhY2goYWRkciA9PiBhZGRyLmlzRGVmYXVsdCA9IGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgYWRkcmVzcywgbWFrZSBpdCBkZWZhdWx0XG4gICAgY29uc3QgaXNGaXJzdEFkZHJlc3MgPSBhZGRyZXNzZXMubGVuZ3RoID09PSAwO1xuICAgIFxuICAgIGNvbnN0IG5ld0FkZHJlc3M6IEFkZHJlc3MgPSB7XG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICAuLi5kYXRhLFxuICAgICAgaXNEZWZhdWx0OiBkYXRhLmlzRGVmYXVsdCB8fCBpc0ZpcnN0QWRkcmVzcyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGFkZHJlc3Nlcy5wdXNoKG5ld0FkZHJlc3MpO1xuICAgIHRoaXMuc2F2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIFxuICAgIHJldHVybiBuZXdBZGRyZXNzO1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZUFkZHJlc3MoaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxBZGRBZGRyZXNzRGF0YT4pOiBBZGRyZXNzIHwgbnVsbCB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gdGhpcy5nZXRBZGRyZXNzZXMoKTtcbiAgICBjb25zdCBpbmRleCA9IGFkZHJlc3Nlcy5maW5kSW5kZXgoYWRkciA9PiBhZGRyLmlkID09PSBpZCk7XG4gICAgXG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgLy8gSWYgc2V0dGluZyBhcyBkZWZhdWx0LCB1bnNldCBvdGhlcnNcbiAgICBpZiAoZGF0YS5pc0RlZmF1bHQpIHtcbiAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHIgPT4gYWRkci5pc0RlZmF1bHQgPSBmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIGFkZHJlc3Nlc1tpbmRleF0gPSB7XG4gICAgICAuLi5hZGRyZXNzZXNbaW5kZXhdLFxuICAgICAgLi4uZGF0YSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5zYXZlQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG4gICAgcmV0dXJuIGFkZHJlc3Nlc1tpbmRleF07XG4gIH1cblxuICBzdGF0aWMgZGVsZXRlQWRkcmVzcyhpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gdGhpcy5nZXRBZGRyZXNzZXMoKTtcbiAgICBjb25zdCBmaWx0ZXJlZEFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5maWx0ZXIoYWRkciA9PiBhZGRyLmlkICE9PSBpZCk7XG4gICAgXG4gICAgaWYgKGZpbHRlcmVkQWRkcmVzc2VzLmxlbmd0aCA9PT0gYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBZGRyZXNzIG5vdCBmb3VuZFxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBkZWxldGVkIHRoZSBkZWZhdWx0IGFkZHJlc3MsIG1ha2UgdGhlIGZpcnN0IHJlbWFpbmluZyBhZGRyZXNzIGRlZmF1bHRcbiAgICBjb25zdCBkZWxldGVkQWRkcmVzcyA9IGFkZHJlc3Nlcy5maW5kKGFkZHIgPT4gYWRkci5pZCA9PT0gaWQpO1xuICAgIGlmIChkZWxldGVkQWRkcmVzcz8uaXNEZWZhdWx0ICYmIGZpbHRlcmVkQWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZpbHRlcmVkQWRkcmVzc2VzWzBdLmlzRGVmYXVsdCA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2F2ZUFkZHJlc3NlcyhmaWx0ZXJlZEFkZHJlc3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgc2V0RGVmYXVsdEFkZHJlc3MoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3QgdGFyZ2V0QWRkcmVzcyA9IGFkZHJlc3Nlcy5maW5kKGFkZHIgPT4gYWRkci5pZCA9PT0gaWQpO1xuICAgIFxuICAgIGlmICghdGFyZ2V0QWRkcmVzcykgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFVuc2V0IGFsbCBkZWZhdWx0cyBhbmQgc2V0IHRoZSB0YXJnZXQgYXMgZGVmYXVsdFxuICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHIgPT4ge1xuICAgICAgYWRkci5pc0RlZmF1bHQgPSBhZGRyLmlkID09PSBpZDtcbiAgICAgIGlmIChhZGRyLmlkID09PSBpZCkge1xuICAgICAgICBhZGRyLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnNhdmVBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZWZhdWx0QWRkcmVzcygpOiBBZGRyZXNzIHwgbnVsbCB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gdGhpcy5nZXRBZGRyZXNzZXMoKTtcbiAgICByZXR1cm4gYWRkcmVzc2VzLmZpbmQoYWRkciA9PiBhZGRyLmlzRGVmYXVsdCkgfHwgYWRkcmVzc2VzWzBdIHx8IG51bGw7XG4gIH1cbn0iXSwibmFtZXMiOlsiQUREUkVTU0VTX0tFWSIsIkFkZHJlc3NTdG9yYWdlIiwiZ2VuZXJhdGVJZCIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJnZXRBZGRyZXNzZXMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYWRkcmVzc2VzIiwiSlNPTiIsInBhcnNlIiwibWlncmF0ZWRBZGRyZXNzZXMiLCJtYXAiLCJhZGRyIiwibGVnYWN5IiwiZnVsbEFkZHJlc3MiLCJhZGRyZXNzIiwid2FyZCIsImRpc3RyaWN0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJpZCIsIm5hbWUiLCJwaG9uZSIsImNpdHkiLCJpc0RlZmF1bHQiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImxlbmd0aCIsInNhdmVBZGRyZXNzZXMiLCJlcnJvciIsImNvbnNvbGUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiYWRkQWRkcmVzcyIsImRhdGEiLCJmb3JFYWNoIiwiaXNGaXJzdEFkZHJlc3MiLCJuZXdBZGRyZXNzIiwicHVzaCIsInVwZGF0ZUFkZHJlc3MiLCJpbmRleCIsImZpbmRJbmRleCIsImRlbGV0ZUFkZHJlc3MiLCJmaWx0ZXJlZEFkZHJlc3NlcyIsImRlbGV0ZWRBZGRyZXNzIiwiZmluZCIsInNldERlZmF1bHRBZGRyZXNzIiwidGFyZ2V0QWRkcmVzcyIsImdldERlZmF1bHRBZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/addressStorage.ts\n"));

/***/ })

});