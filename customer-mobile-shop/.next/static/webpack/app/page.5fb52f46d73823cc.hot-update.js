"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/addressStorage.ts":
/*!*************************************!*\
  !*** ./src/utils/addressStorage.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressStorage: () => (/* binding */ AddressStorage)\n/* harmony export */ });\nconst ADDRESSES_KEY = 'user_addresses';\nclass AddressStorage {\n    static generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    static getAddresses() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(ADDRESSES_KEY);\n            if (!stored) return [];\n            const addresses = JSON.parse(stored);\n            // Migrate legacy addresses to new format\n            const migratedAddresses = addresses.map((addr)=>{\n                // Case 1: Very old format with ward/district/city separate\n                if ('ward' in addr || 'district' in addr) {\n                    const legacy = addr;\n                    const fullAddress = [\n                        legacy.address,\n                        legacy.ward,\n                        legacy.district\n                    ].filter(Boolean).join(', ');\n                    return {\n                        id: legacy.id,\n                        name: legacy.name,\n                        phone: legacy.phone,\n                        address: \"\".concat(fullAddress, \", \").concat(legacy.city),\n                        isDefault: legacy.isDefault,\n                        createdAt: legacy.createdAt,\n                        updatedAt: new Date().toISOString()\n                    };\n                }\n                // Case 2: Previous format with separate fullAddress + city\n                if ('city' in addr && !('address' in addr)) {\n                    const prevFormat = addr;\n                    return {\n                        id: prevFormat.id,\n                        name: prevFormat.name,\n                        phone: prevFormat.phone,\n                        address: prevFormat.fullAddress ? \"\".concat(prevFormat.fullAddress, \", \").concat(prevFormat.city) : prevFormat.city,\n                        isDefault: prevFormat.isDefault,\n                        createdAt: prevFormat.createdAt,\n                        updatedAt: new Date().toISOString()\n                    };\n                }\n                // Case 3: Already new format, but ensure address field exists\n                const current = addr;\n                return {\n                    ...current,\n                    address: current.address || ''\n                };\n            });\n            // Save migrated addresses\n            if (migratedAddresses.length > 0) {\n                this.saveAddresses(migratedAddresses);\n            }\n            return migratedAddresses;\n        } catch (error) {\n            console.error('Failed to get addresses:', error);\n            return [];\n        }\n    }\n    static saveAddresses(addresses) {\n        if (false) {}\n        try {\n            localStorage.setItem(ADDRESSES_KEY, JSON.stringify(addresses));\n        } catch (error) {\n            console.error('Failed to save addresses:', error);\n        }\n    }\n    static addAddress(data) {\n        const addresses = this.getAddresses();\n        // If this is set as default, unset other defaults\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        // If this is the first address, make it default\n        const isFirstAddress = addresses.length === 0;\n        const newAddress = {\n            id: this.generateId(),\n            ...data,\n            isDefault: data.isDefault || isFirstAddress,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        addresses.push(newAddress);\n        this.saveAddresses(addresses);\n        return newAddress;\n    }\n    static updateAddress(id, data) {\n        const addresses = this.getAddresses();\n        const index = addresses.findIndex((addr)=>addr.id === id);\n        if (index === -1) return null;\n        // If setting as default, unset others\n        if (data.isDefault) {\n            addresses.forEach((addr)=>addr.isDefault = false);\n        }\n        addresses[index] = {\n            ...addresses[index],\n            ...data,\n            updatedAt: new Date().toISOString()\n        };\n        this.saveAddresses(addresses);\n        return addresses[index];\n    }\n    static deleteAddress(id) {\n        const addresses = this.getAddresses();\n        const filteredAddresses = addresses.filter((addr)=>addr.id !== id);\n        if (filteredAddresses.length === addresses.length) {\n            return false; // Address not found\n        }\n        // If we deleted the default address, make the first remaining address default\n        const deletedAddress = addresses.find((addr)=>addr.id === id);\n        if ((deletedAddress === null || deletedAddress === void 0 ? void 0 : deletedAddress.isDefault) && filteredAddresses.length > 0) {\n            filteredAddresses[0].isDefault = true;\n        }\n        this.saveAddresses(filteredAddresses);\n        return true;\n    }\n    static setDefaultAddress(id) {\n        const addresses = this.getAddresses();\n        const targetAddress = addresses.find((addr)=>addr.id === id);\n        if (!targetAddress) return false;\n        // Unset all defaults and set the target as default\n        addresses.forEach((addr)=>{\n            addr.isDefault = addr.id === id;\n            if (addr.id === id) {\n                addr.updatedAt = new Date().toISOString();\n            }\n        });\n        this.saveAddresses(addresses);\n        return true;\n    }\n    static getDefaultAddress() {\n        const addresses = this.getAddresses();\n        return addresses.find((addr)=>addr.isDefault) || addresses[0] || null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hZGRyZXNzU3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsZ0JBQWdCO0FBZ0JmLE1BQU1DO0lBQ1gsT0FBZUMsYUFBcUI7UUFDbEMsT0FBT0MsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLENBQUMsTUFBTUMsS0FBS0MsTUFBTSxHQUFHRixRQUFRLENBQUMsSUFBSUcsTUFBTSxDQUFDO0lBQ3JFO0lBRUEsT0FBT0MsZUFBMEI7UUFDL0IsSUFBSSxLQUE2QixFQUFFLEVBQVU7UUFFN0MsSUFBSTtZQUNGLE1BQU1DLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ1o7WUFDcEMsSUFBSSxDQUFDVSxRQUFRLE9BQU8sRUFBRTtZQUV0QixNQUFNRyxZQUF5Q0MsS0FBS0MsS0FBSyxDQUFDTDtZQUUxRCx5Q0FBeUM7WUFDekMsTUFBTU0sb0JBQStCSCxVQUFVSSxHQUFHLENBQUNDLENBQUFBO2dCQUNqRCwyREFBMkQ7Z0JBQzNELElBQUksVUFBVUEsUUFBUSxjQUFjQSxNQUFNO29CQUN4QyxNQUFNQyxTQUFTRDtvQkFDZixNQUFNRSxjQUFjO3dCQUNsQkQsT0FBT0UsT0FBTzt3QkFDZEYsT0FBT0csSUFBSTt3QkFDWEgsT0FBT0ksUUFBUTtxQkFDaEIsQ0FBQ0MsTUFBTSxDQUFDQyxTQUFTQyxJQUFJLENBQUM7b0JBRXZCLE9BQU87d0JBQ0xDLElBQUlSLE9BQU9RLEVBQUU7d0JBQ2JDLE1BQU1ULE9BQU9TLElBQUk7d0JBQ2pCQyxPQUFPVixPQUFPVSxLQUFLO3dCQUNuQlIsU0FBUyxHQUFtQkYsT0FBaEJDLGFBQVksTUFBZ0IsT0FBWkQsT0FBT1csSUFBSTt3QkFDdkNDLFdBQVdaLE9BQU9ZLFNBQVM7d0JBQzNCQyxXQUFXYixPQUFPYSxTQUFTO3dCQUMzQkMsV0FBVyxJQUFJOUIsT0FBTytCLFdBQVc7b0JBQ25DO2dCQUNGO2dCQUVBLDJEQUEyRDtnQkFDM0QsSUFBSSxVQUFVaEIsUUFBUSxDQUFFLGNB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cy9hZGRyZXNzU3RvcmFnZS50cz9iMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkZHJlc3MsIEFkZEFkZHJlc3NEYXRhIH0gZnJvbSAnQC90eXBlcy9hZGRyZXNzJztcblxuY29uc3QgQUREUkVTU0VTX0tFWSA9ICd1c2VyX2FkZHJlc3Nlcyc7XG5cbi8vIExlZ2FjeSBhZGRyZXNzIGZvcm1hdCBmb3IgbWlncmF0aW9uXG5pbnRlcmZhY2UgTGVnYWN5QWRkcmVzcyB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB3YXJkPzogc3RyaW5nO1xuICBkaXN0cmljdD86IHN0cmluZztcbiAgY2l0eTogc3RyaW5nO1xuICBpc0RlZmF1bHQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICB1cGRhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEFkZHJlc3NTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBZGRyZXNzZXMoKTogQWRkcmVzc1tdIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQUREUkVTU0VTX0tFWSk7XG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIFtdO1xuICAgICAgXG4gICAgICBjb25zdCBhZGRyZXNzZXM6IChBZGRyZXNzIHwgTGVnYWN5QWRkcmVzcylbXSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgIFxuICAgICAgLy8gTWlncmF0ZSBsZWdhY3kgYWRkcmVzc2VzIHRvIG5ldyBmb3JtYXRcbiAgICAgIGNvbnN0IG1pZ3JhdGVkQWRkcmVzc2VzOiBBZGRyZXNzW10gPSBhZGRyZXNzZXMubWFwKGFkZHIgPT4ge1xuICAgICAgICAvLyBDYXNlIDE6IFZlcnkgb2xkIGZvcm1hdCB3aXRoIHdhcmQvZGlzdHJpY3QvY2l0eSBzZXBhcmF0ZVxuICAgICAgICBpZiAoJ3dhcmQnIGluIGFkZHIgfHwgJ2Rpc3RyaWN0JyBpbiBhZGRyKSB7XG4gICAgICAgICAgY29uc3QgbGVnYWN5ID0gYWRkciBhcyBMZWdhY3lBZGRyZXNzO1xuICAgICAgICAgIGNvbnN0IGZ1bGxBZGRyZXNzID0gW1xuICAgICAgICAgICAgbGVnYWN5LmFkZHJlc3MsXG4gICAgICAgICAgICBsZWdhY3kud2FyZCxcbiAgICAgICAgICAgIGxlZ2FjeS5kaXN0cmljdFxuICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBsZWdhY3kuaWQsXG4gICAgICAgICAgICBuYW1lOiBsZWdhY3kubmFtZSxcbiAgICAgICAgICAgIHBob25lOiBsZWdhY3kucGhvbmUsXG4gICAgICAgICAgICBhZGRyZXNzOiBgJHtmdWxsQWRkcmVzc30sICR7bGVnYWN5LmNpdHl9YCxcbiAgICAgICAgICAgIGlzRGVmYXVsdDogbGVnYWN5LmlzRGVmYXVsdCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbGVnYWN5LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBVcGRhdGUgdGltZXN0YW1wIGZvciBtaWdyYXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYXNlIDI6IFByZXZpb3VzIGZvcm1hdCB3aXRoIHNlcGFyYXRlIGZ1bGxBZGRyZXNzICsgY2l0eVxuICAgICAgICBpZiAoJ2NpdHknIGluIGFkZHIgJiYgISgnYWRkcmVzcycgaW4gYWRkcikpIHtcbiAgICAgICAgICBjb25zdCBwcmV2Rm9ybWF0ID0gYWRkciBhcyBhbnk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBwcmV2Rm9ybWF0LmlkLFxuICAgICAgICAgICAgbmFtZTogcHJldkZvcm1hdC5uYW1lLFxuICAgICAgICAgICAgcGhvbmU6IHByZXZGb3JtYXQucGhvbmUsXG4gICAgICAgICAgICBhZGRyZXNzOiBwcmV2Rm9ybWF0LmZ1bGxBZGRyZXNzID8gYCR7cHJldkZvcm1hdC5mdWxsQWRkcmVzc30sICR7cHJldkZvcm1hdC5jaXR5fWAgOiBwcmV2Rm9ybWF0LmNpdHksXG4gICAgICAgICAgICBpc0RlZmF1bHQ6IHByZXZGb3JtYXQuaXNEZWZhdWx0LFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBwcmV2Rm9ybWF0LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhc2UgMzogQWxyZWFkeSBuZXcgZm9ybWF0LCBidXQgZW5zdXJlIGFkZHJlc3MgZmllbGQgZXhpc3RzXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBhZGRyIGFzIEFkZHJlc3M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY3VycmVudCxcbiAgICAgICAgICBhZGRyZXNzOiBjdXJyZW50LmFkZHJlc3MgfHwgJycsIC8vIFNhZmVndWFyZCBhZ2FpbnN0IG1pc3NpbmcgYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgbWlncmF0ZWQgYWRkcmVzc2VzXG4gICAgICBpZiAobWlncmF0ZWRBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNhdmVBZGRyZXNzZXMobWlncmF0ZWRBZGRyZXNzZXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbWlncmF0ZWRBZGRyZXNzZXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWRkcmVzc2VzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2F2ZUFkZHJlc3NlcyhhZGRyZXNzZXM6IEFkZHJlc3NbXSk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBRERSRVNTRVNfS0VZLCBKU09OLnN0cmluZ2lmeShhZGRyZXNzZXMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgYWRkcmVzc2VzOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWRkQWRkcmVzcyhkYXRhOiBBZGRBZGRyZXNzRGF0YSk6IEFkZHJlc3Mge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgXG4gICAgLy8gSWYgdGhpcyBpcyBzZXQgYXMgZGVmYXVsdCwgdW5zZXQgb3RoZXIgZGVmYXVsdHNcbiAgICBpZiAoZGF0YS5pc0RlZmF1bHQpIHtcbiAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHIgPT4gYWRkci5pc0RlZmF1bHQgPSBmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGFkZHJlc3MsIG1ha2UgaXQgZGVmYXVsdFxuICAgIGNvbnN0IGlzRmlyc3RBZGRyZXNzID0gYWRkcmVzc2VzLmxlbmd0aCA9PT0gMDtcbiAgICBcbiAgICBjb25zdCBuZXdBZGRyZXNzOiBBZGRyZXNzID0ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgLi4uZGF0YSxcbiAgICAgIGlzRGVmYXVsdDogZGF0YS5pc0RlZmF1bHQgfHwgaXNGaXJzdEFkZHJlc3MsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBhZGRyZXNzZXMucHVzaChuZXdBZGRyZXNzKTtcbiAgICB0aGlzLnNhdmVBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICBcbiAgICByZXR1cm4gbmV3QWRkcmVzcztcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVBZGRyZXNzKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8QWRkQWRkcmVzc0RhdGE+KTogQWRkcmVzcyB8IG51bGwge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3QgaW5kZXggPSBhZGRyZXNzZXMuZmluZEluZGV4KGFkZHIgPT4gYWRkci5pZCA9PT0gaWQpO1xuICAgIFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBudWxsO1xuICAgIFxuICAgIC8vIElmIHNldHRpbmcgYXMgZGVmYXVsdCwgdW5zZXQgb3RoZXJzXG4gICAgaWYgKGRhdGEuaXNEZWZhdWx0KSB7XG4gICAgICBhZGRyZXNzZXMuZm9yRWFjaChhZGRyID0+IGFkZHIuaXNEZWZhdWx0ID0gZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICBhZGRyZXNzZXNbaW5kZXhdID0ge1xuICAgICAgLi4uYWRkcmVzc2VzW2luZGV4XSxcbiAgICAgIC4uLmRhdGEsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2F2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIHJldHVybiBhZGRyZXNzZXNbaW5kZXhdO1xuICB9XG5cbiAgc3RhdGljIGRlbGV0ZUFkZHJlc3MoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3QgZmlsdGVyZWRBZGRyZXNzZXMgPSBhZGRyZXNzZXMuZmlsdGVyKGFkZHIgPT4gYWRkci5pZCAhPT0gaWQpO1xuICAgIFxuICAgIGlmIChmaWx0ZXJlZEFkZHJlc3Nlcy5sZW5ndGggPT09IGFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gQWRkcmVzcyBub3QgZm91bmRcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UgZGVsZXRlZCB0aGUgZGVmYXVsdCBhZGRyZXNzLCBtYWtlIHRoZSBmaXJzdCByZW1haW5pbmcgYWRkcmVzcyBkZWZhdWx0XG4gICAgY29uc3QgZGVsZXRlZEFkZHJlc3MgPSBhZGRyZXNzZXMuZmluZChhZGRyID0+IGFkZHIuaWQgPT09IGlkKTtcbiAgICBpZiAoZGVsZXRlZEFkZHJlc3M/LmlzRGVmYXVsdCAmJiBmaWx0ZXJlZEFkZHJlc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBmaWx0ZXJlZEFkZHJlc3Nlc1swXS5pc0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhdmVBZGRyZXNzZXMoZmlsdGVyZWRBZGRyZXNzZXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIHNldERlZmF1bHRBZGRyZXNzKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLmdldEFkZHJlc3NlcygpO1xuICAgIGNvbnN0IHRhcmdldEFkZHJlc3MgPSBhZGRyZXNzZXMuZmluZChhZGRyID0+IGFkZHIuaWQgPT09IGlkKTtcbiAgICBcbiAgICBpZiAoIXRhcmdldEFkZHJlc3MpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBVbnNldCBhbGwgZGVmYXVsdHMgYW5kIHNldCB0aGUgdGFyZ2V0IGFzIGRlZmF1bHRcbiAgICBhZGRyZXNzZXMuZm9yRWFjaChhZGRyID0+IHtcbiAgICAgIGFkZHIuaXNEZWZhdWx0ID0gYWRkci5pZCA9PT0gaWQ7XG4gICAgICBpZiAoYWRkci5pZCA9PT0gaWQpIHtcbiAgICAgICAgYWRkci51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5zYXZlQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVmYXVsdEFkZHJlc3MoKTogQWRkcmVzcyB8IG51bGwge1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMuZ2V0QWRkcmVzc2VzKCk7XG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5maW5kKGFkZHIgPT4gYWRkci5pc0RlZmF1bHQpIHx8IGFkZHJlc3Nlc1swXSB8fCBudWxsO1xuICB9XG59Il0sIm5hbWVzIjpbIkFERFJFU1NFU19LRVkiLCJBZGRyZXNzU3RvcmFnZSIsImdlbmVyYXRlSWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyIiwiZ2V0QWRkcmVzc2VzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImFkZHJlc3NlcyIsIkpTT04iLCJwYXJzZSIsIm1pZ3JhdGVkQWRkcmVzc2VzIiwibWFwIiwiYWRkciIsImxlZ2FjeSIsImZ1bGxBZGRyZXNzIiwiYWRkcmVzcyIsIndhcmQiLCJkaXN0cmljdCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiaWQiLCJuYW1lIiwicGhvbmUiLCJjaXR5IiwiaXNEZWZhdWx0IiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwidG9JU09TdHJpbmciLCJwcmV2Rm9ybWF0IiwiY3VycmVudCIsImxlbmd0aCIsInNhdmVBZGRyZXNzZXMiLCJlcnJvciIsImNvbnNvbGUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiYWRkQWRkcmVzcyIsImRhdGEiLCJmb3JFYWNoIiwiaXNGaXJzdEFkZHJlc3MiLCJuZXdBZGRyZXNzIiwicHVzaCIsInVwZGF0ZUFkZHJlc3MiLCJpbmRleCIsImZpbmRJbmRleCIsImRlbGV0ZUFkZHJlc3MiLCJmaWx0ZXJlZEFkZHJlc3NlcyIsImRlbGV0ZWRBZGRyZXNzIiwiZmluZCIsInNldERlZmF1bHRBZGRyZXNzIiwidGFyZ2V0QWRkcmVzcyIsImdldERlZmF1bHRBZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/addressStorage.ts\n"));

/***/ })

});